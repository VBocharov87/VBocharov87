
Любой анонимный внутренний класс может за один раз реализовать только один интерфейс. Так же, за один раз можно либо расширить класс, 
либо реализовать интерфейс, но не одновременно.
Анонимные классы полезны в некоторых "узких" участках кода, когда нет необходимости их потом переиспользовать где-то еще. Чаще всего 
на практике используют лишь один экземпляр анонимного класса. Если же реализацию интерфейса придется использовать много раз в коде — 
то лучше использовать лямбда-выражения (лямбды), которые стали доступны начиная с JAVA 8.
Например, реализацию интерфейса Consumer, в текущем уроке, можно переписать с помощью лямбд:

Проверить, равны ли ссылки на анонимные классы в рамках нестатик блока. 


оно тебе не нужно, начни с https://eightm.github.io/JavaBackendStartGuide/
задачи отсюда можно взять
https://github.com/rusinek-wojciech/hyperskill-java-track

Можно еще вот это
https://cleannetcode.github.io/Dotnet-Awesome-Pet-Project-Ideas/



АВТОУПАКОВКА - пулы работают только при автоупаковке. когда объекту класска-упаковки присваивается значение переменной 
примитивного типа, но не только примитивного, т.к. строка String s1 = "reb"; - это тоже автоупаковка, проходящая
через пул.

АВТОРАСПАКОВКА - когда переменной примитивного типа присваевается объект класса-обертки (мб его значение?)
Автоупаковка и автораспаковка - перевод примитива в объект и наоборот.
Unboxing не происходит при сравнении (==, !=), происходит при арифметических операциях. Остаток от деления работает.
https://javarush.com/groups/posts/706-avtoupakovka-i-raspakovka-v-java

Раньше создавали объекты: Integer iOb3 = new Integer(120); (тут ссылка, сравнить невозможно)
Сейчас: Integer iOb2 = 100; (здесь от -128 до 127 сравнивать можно, благодаря пулу, вернюю границу можно изменять (127))
Тут объекты не создаются, а берутся из pool и классы-обёртки имеют одну ссылку. Или создаются, но имеют ссылку на одно и
то же значение пула?

Если передаем объект в метод, в коротом есть перегрнузка Integer, вызовется именно он, несмотря на наличие 
перегрузки с int

Для классов-оберток значение по умолчанию равно null.

--------------------------------------------------------------------------------------------------
Ребят, для чего нужен внутренний класс простыми словами? В чем его отличие от класса-наследника?
Только тем, что его (внутренний) можно объявить статическим и пользоваться без создания объекта внешнего класса?
--------------------------------------------------------------------------------------------------
как сделать так, что бы метод возвращал более одного значения?
--------------------------------------------------------------------------------------------------
StackTraceElement[] methods = Thread.currentThread().getStackTrace() - как вызывается последний метод статического метода?
--------------------------------------------------------------------------------------------------
Класс Calendar + время
--------------------------------------------------------------------------------------------------
Что за двойная кодировка в Юникод UTF-16?
--------------------------------------------------------------------------------------------------
Горячие клавиши IDEA
--------------------------------------------------------------------------------------------------
Композиция классов
--------------------------------------------------------------------------------------------------
Разобраться со всеми коллекциями
--------------------------------------------------------------------------------------------------
числа с плавающей точкой 
https://javarush.com/quests/lectures/questsyntaxpro.level07.lecture02
--------------------------------------------------------------------------------------------------
Переопределение, это же не только для наследников? ДА.
--------------------------------------------------------------------------------------------------
HashCode & HashMap


return Objects.hash(model, color, price); Как работает встроенный hashCode? Я так понимаю, он выбывает hash у Object, тот принимает
через varargs массив (?) значений, после чего передает его в Arrays.hashCode, тот принимает массив объектов (значений?) прогоняет их все
через цикл, увеличивая result, внутри коротого вызывается метод hashCode класса Object для каждого в отдельности, но как он реализован
в Object не видно.

--------------------------------------------------------------------------------------------------
регулярные выражения
--------------------------------------------------------------------------------------------------
Сортировки
--------------------------------------------------------------------------------------------------
Debug
--------------------------------------------------------------------------------------------------
Почему arr.length - потому, что это поле экземпляра класса, т.е. у нас есть объект, , возвращается поле (его значение)
length, а s.length() - вызывается метод, кот. возвращает значение
--------------------------------------------------------------------------------------------------
Может ли switch перебрать массив?
Операторы бывают примитывными и сложными. Например примитив просто что-то делает: -, +, ==
Сложный оператор что-то делает, например:
if () {} - в данном случае выполняет выражение
Оператор именно что-то делает, он не может вернуть значение. switch был оператором, он как if заставлял делать что-то:
case 1: result = a + b;, но не возвращал значение.

Выражение - возвращает значение. После выражения мы ставим ";" (как в случае с switch()). 
if - оператор, ; не ставится
switch без ; - оператор
switch c ; - выражение
поэтому тернарка, в конце кот ставится ; (а она всегда там ставится), явл выражением.
--------------------------------------------------------------------------------------------------
Если метод не статический, то мы не можем получить к нему доступ, без создания объекта? - Нет, конечно.
Тогда в каких случаях нужно использовать статический метод? То есть в каких случаях требуется создание объекта, а когда мы можем 
обойтись статическим методом? - В классе Math можно обходиться статическими методами. А массиве length явл. статической переменной 
final по всей видимости. Создание объекта необходимо, когда мы создаем объект один раз и в дальнейшем пользуемся его полями
множество раз в разных методах, без необходимости указания в них множества значений всех полей объекта.
--------------------------------------------------------------------------------------------------
Аннотации
--------------------------------------------------------------------------------------------------
varargs
--------------------------------------------------------------------------------------------------
функциональное программирование
Comparator
--------------------------------------------------------------------------------------------------
Writer (на листике), сериализация, отличия io от nio, каналы nio
--------------------------------------------------------------------------------------------------
для чего нужны вложенные классы?
--------------------------------------------------------------------------------------------------
почитать про коллекторы https://habr.com/ru/articles/445622/
--------------------------------------------------------------------------------------------------
https://javarush.com/groups/posts/607-kommentarii-v-java--ne-vsje-tak-prosto

--------------------------------------------------------------------------------------------------

System.out.format("%02d:%02d:%02d", T / 3600 % 24, (T / 60) % 60, T % 60);

System.out.printf("Сложение: %1$d + %2$d = %3$d\nВычитание: %1$d - %2$d = %4$d", x, y, x+y, x-y);

Если нужно просто вывести число с определённым количеством знаков после запятой, можно использовать для этого форматирование строк:
double x = 25.364789;
String formatted = String.format("%.3f", x);
System.out.println(formatted);    // 25.365
В этом примере мы пользуемся методом format() класса String. В качестве аргументов этот метод получает формат числа - количество знаков после запятой (.3 - три знака),
 тип числа (f - число с плавающей точкой) и само число, которое нужно округлить.

что такое литерал?

А ещё массивы можно заполнять так:

import java.util.Arrays;
import java.util.Random;

public class Test {
  public static void main(String[] args) {

    int[] arr = new int[10];
    
    // заполнить массив одинаковыми значениями
    Arrays.fill(arr, 14);
    System.out.println(Arrays.toString(arr));
    
    // заполнить массив значениями, вычисленными как функция от индекса
    Arrays.setAll(arr, i -> i * i);		// приняли индекс массива!!!!! ООООУУОУОУОУООУф
    System.out.println(Arrays.toString(arr));
    
    // заполнить массив случайными числами от 0 до 99
    Random rnd = new Random();
    Arrays.setAll(arr, i -> rnd.nextInt(0, 100));
    System.out.println(Arrays.toString(arr));

  }

}
Правда, для setAll() нужна Java поновее той что используется в данном курсе :)

(п.с. от 8й джавы появились лямбда)

```````````
        System.out.println(Arrays.toString(myArr)
                .replace("[", "")
                .replace("]", "")
                .replace(",", ""));
````````````

----------------
Заполнение двумерного массива без инфо о его размере (динамическая инициализация):

import java.util.Arrays;
import java.util.Scanner;

class MyClass {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int i = 0;
        String[][] arr = new String[0][];

        while (sc.hasNextLine()) {
            arr = Arrays.copyOf(arr,i+1);
            arr[i] = sc.nextLine().split(" ");
            System.out.println(Arrays.toString(arr[i]));
            i++;
        }

        sc.close();
    }
}
----------------


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ GIT ~~~~~~~~~~~~~~~~~~~~ 

Репозиторий хранит проект файлы и т.п. 
Может хранить несоклько проектов. Одним словом что-то изеняемое, где фиксируются те самые изменения.
При любом изменении файла / дополнении репозитория новым файлом, их нужно добавить ч/add в staging area (промежуточная зона) для последующей
отправки на коммит. То есть, все что менялось в проекте, эти изменения будут отслеживаться, и их нужно внести ч/add, а потом закоммитить.


git status 			- статус репозитория, нужно ли что-то коммитить
git commit			- сделать слепок (вызывается после add)
git commit -m "Message"		- сделать слепок с указанием комментария, что именно было изменено, по отношении к прдд. коммиту.
git log				- посмотреть все коммиты в нашем репозитории (все контрольные точки) 

git diff (no arguments)		- покажет, какие изменения вы внесли в файлы, которые еще не были добавлены в индекс командой git add, то есть
				что мы наизменяли за сегодняшний день
git diff --staged		- покажет 



Разные способы сделать git add (добавить файл на отслеживание):

git add <список файлов> 	- git add file1 file2
git add . 			- добавить все файлы в текущей папке
git add *.java 			- добавить все файлы в текущей папке с
				расширением .java
git add someDir/*.java 		- добавить все файлы в папке someDir с
				расширением .java
git add someDir/ 		- добавить все файлы в папке someDir
git add “*.java” 		- добавить все файлы в проекте с
				расширением .java


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ STREAM ~~~~~~~~~~~~~~~~~~~~ 

========================================================================
Лексиграфический порядок. Наиболее 10 часто встречающихся слов +
	лекс. упоряд., если одинаковое кол-во встречаний.


    bufferedReader.lines()
            .flatMap(word -> Stream.of(word.toLowerCase().replaceAll("[\\p{Punct}\\s]+", " ").split(" ")))
            .collect(Collectors.groupingBy(word -> word, Collectors.counting()))
            .entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed().thenComparing(Map.Entry.comparingByKey()))
            //и вот теперь, когда у нас появился поток упордоченных Entry's
            .limit(10).forEach(entry -> System.out.println(entry.getKey()));   
Прим:
reversed() - метод Comporator'a
Map.Entry.<String, Long>comparingByValue() - у интерфейса Map есть внутренный интерфейс Entry, у которого есть параметризованный метод
						сomparingByValue
thenComparing - метод Comporator'a. Применяет второй компоратор, который срабатывает только когда значения первого равны. Уточняющий.
		срабатывает последним, после первого и reverse().

=======================================================================
Факториал числа:

public static BigInteger factorial(int value) {
	// Твой код здесь
    return IntStream.rangeClosed(1, value)
            .mapToObj(a -> new BigInteger(String.valueOf(a)))
            .reduce(BigInteger.ONE, BigInteger::multiply);
}

Прим: reduce собирает множество (поток) элементов в один по правилу в скобках (первый элемент - аккумелятор, начальное значение).

=======================================================================

Stream из List

List<String> list = new ArrayList<>();
list.stream();
list.parallelStream(); // параллельный поток

-----------------
 

Stream из Map

Map<String, String> map = new HashMap<>();
map.entrySet().stream();
map.values().stream();
 
 -------------------

Stream из массива, используя статический метод класса Arrays

String[] array = new String[10];
Arrays.stream(array);
 
----------------------------
 

Stream из элементов, используя статические методы Классов-потоков

Stream.of("a", "b", "c"); // поток из элементов
Stream.of(array); // поток из элементов массива
Stream.of(list); // поток из элементов списка List


Stream.generate(Math::random); // генерация потока рандомных чисел
Stream.concat(stream1, stream2); // объединяет два потока в один
IntStream.range(1, 10); // поток диапазона чисел от 1 до 9
IntStream.rangeClosed(1, 10); // поток диапазона чисел от 1 до 10
 
-----------------------------------------
 
Stream из строк буфера BufferedReader

BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
bufferedReader.lines();
 
------------------------------------------------

Stream из строк файла через статический метод класса Files

Path path = Path.of("/root/test.txt");
Files.lines(path);
 
----------------------------------------
 

Stream из случайных чисел Random

Random random = new Random();
random.ints();
random.longs();
random.doubles();

------------------------------------------------------------

BaseStream определяет базовый функционал для работы с потоками, которые реализуется через его методы:

void close(): закрывает поток
boolean isParallel(): возвращает true, если поток является параллельным
Iterator<Т> iterator(): возвращает ссылку на итератор потока, терминальная операция
Spliterator<Т> spliterator(): возвращает ссылку на сплитератор потока
S parallel(): возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)
S sequential(): возвращает последовательный поток
S unordered(): возвращает неупорядоченный поток

 

От интерфейса BaseStream наследуется ряд интерфейсов, предназначенных для создания конкретных потоков:

Stream<T>: используется для потоков данных, представляющих любой ссылочный тип
IntStream: используется для потоков с типом данных int
DoubleStream: используется для потоков с типом данных double
LongStream: используется для потоков с типом данных long

--------------------------------------------------------------


Методы				Описание
Stream<T> of()			Создает поток из набора объектов
Stream<T> generate()		Генерирует поток по заданному правилу
Stream<T> concat()		Объединяет вместе несколько потоков
Stream<T> filter()		Фильтрует данные: пропускает только данные, которые соответствуют заданному правилу
Stream<T> distinct()		Удаляет дубликаты: не пропускает данные, которые уже были
Stream<T> sorted()		Сортирует данные
Stream<T> peek()		Выполняет действие над каждым данным
Stream<T> limit(n)		Обрезает данные после достижения лимита
Stream<T> skip(n)		Пропускает первые n данных
Stream<R> map()			Преобразовывает данные из одного типа в другой
Stream<R> flatMap()		Преобразовывает элементы коллекций в плоский стрим, состоящий из всех элементов тех самых коллекций
boolean anyMatch()		Проверяет, что среди данных потока есть хоть одно, которое соответствует заданному правилу
boolean allMatch()		Проверяет, что все данные в потоке соответствуют заданному правилу
boolean noneMatch()		Проверяет, что никакие данные в потоке не соответствуют заданному правилу
Optional<T> findFirst()		Возвращает первый найденный элемент, который соответствует правилу
Optional<T> findAny()		Возвращает любой элемент из потока, который соответствует правилу
Optional<T> min()		Ищет минимальный элемент в потоке данных
Optional<T> max()		Возвращает максимальный элемент в потоке данных
long count()			Возвращает количество элементов в потоке данных
R collect()			Вычитывает все данные из потока и возвращает их в виде коллекции
Stream<T> takeWhile​(): 		выбирает из потока элементы, пока они соответствуют условию в predicate. 
				Выбранные элементы возвращаются в виде потока. Промежуточная операция.
dropWhile() 			выполняет обратную задачу - он пропускает элементы потока, которые соответствуют условию до тех пор, 
				пока не встретит элемент, который НЕ соответствует условию:
Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
numbers.sorted().dropWhile(n -> n < 0)
    .forEach(n -> System.out.println(n));

iterate()			Этот метод принимает начальное значение seed и функцию f, которая принимает предыдущий элемент и 
				возвращает следующий элемент. Он генерирует бесконечный поток (как generate) элементов типа int, начиная 
				с заданного начального значения и вычисляя каждый следующий элемент с использованием заданной функции.
				Есть в стрим, интСтрим, даблСтрим, лонгСтрим.

public static IntStream pseudoRandomStream(int seed) {
	//твой код здесь
	return IntStream.iterate(seed, n -> {
    	int temp = (int) Math.pow(n, 2);
    	return 100 * (temp % 10_000 / 1000) +
            	10 * (temp % 1000 / 100) +
            	(temp % 100 / 10);
	});
}
-----------------------
Преобразовать поток в строку String Collectors.joining()

String collect = Stream.of("a", "b", "c").collect(Collectors.joining());
------------------------------------------------
Метод boolean anyMatch(правило)

Этот метод проверяет, что в потоке есть хотя бы один элемент, который удовлетворяет правилу, которое передается в метод. 
Если такой элемент есть, метод возвращает true, иначе — false.

Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
boolean result = stream.anyMatch(x -> x > 0);		true

Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);
boolean result = stream.anyMatch(x -> x > 0);		true

Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);
boolean result = stream.filter(x -> x < 0).anyMatch(x -> x > 0);	false

------------------------------------------------

Метод boolean allMatch(правило)
проверяет, что все элементы в потоке соответствуют правилу

Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
boolean result = stream.allMatch(x -> x > 0);		true


------------------------------------------------

boolean noneMatch(правило)
что в потоке нет ни одного элемента, который соответствует переданному правилу

Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);
boolean result = stream.noneMatch(x -> x > 0);		false

Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);
boolean result = stream.filter(x -> x < 0).noneMatch(x -> x > 0);	true

------------------------------------------------------

Метод Collectors.teeing() - это статический метод в классе Collectors, который введен в Java 12. Он используется для выполнения двух 
коллекторов параллельно над элементами потока и затем комбинирования результатов с использованием функции. Этот метод полезен, когда вам 
нужно применить две операции к потоку данных одновременно и затем объединить результаты этих операций.
Возвращает Optional.

Да, метод Collectors.teeing() может принимать два и более коллекторов. В Java 12 и Java 13 он может принимать только два коллектора, но 
начиная с Java 14, появилась возможность передавать больше коллекторов.

Параметры метода teeing():

first: Первый коллектор, который будет применён к элементам потока.
second: Второй коллектор, который также будет применён к элементам потока.
merger: Функция, которая объединяет результаты двух коллекторов в один результат.

double[] result = numbers.collect(
            Collectors.teeing(
                Collectors.averagingInt(Integer::intValue), // первый коллектор: среднее значение
                Collectors.summingInt(Integer::intValue),  // второй коллектор: сумма
                (avg, sum) -> new double[]{avg, sum}       // функция для объединения результатов
            )
        );

------------------------------------------------------

Метод Coollectors.counting
Метод Collectors.counting применяется в Collectors.groupingBy() для вычисления количества элементов в каждой группе:


Map<String, Long> phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany, Collectors.counting()));
         
for(Map.Entry<String, Long> item : phonesByCompany.entrySet()){
 
    System.out.println(item.getKey() + " - " + item.getValue());
}

Вывод:
Google -1
Apple - 2
Samsung - 2

В общем, идея в том, если передать один параметир, то группировка будет по нему (ключ), а в значении будет лист phone, 
а если вторым параметром передать counting, то  создается мапа, ключи - наши значения - они уникальны и повторятся не могут, как же 
подсчитать кол-во таких?
А так, что данный метод записывает количество одинаковых ключей в значение мапы.


------------------------------------------------------

.collect(Collectors.toMap(
                        word -> word, // Ключ - слово
                        word -> 1L,   // Значение - количество повторений (в начале устанавливаем как 1)
                        (oldValue, newValue) -> oldValue + 1L)); // Если ключ уже существует, увеличиваем счетчик повторений

-----------------------------------------------------


Метод Collectors.summing 
применяется для подсчета суммы. В зависимости от типа данных, к которым применяется метод, он имеет следующие формы: summingInt(), 
summingLong(), summingDouble(). Применим этот метод для подсчета стоимости всех смартфонов по компаниям:


Map<String, Integer> phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany, Collectors.summingInt(Phone::getPrice)));
         
for(Map.Entry<String, Integer> item : phonesByCompany.entrySet()){
 
    System.out.println(item.getKey() + " - " + item.getValue());
}


Логика такая же, как у метода Collectors.counting (см. выше).

-------------------------------------------------------


Методы maxBy и minBy
применяются для подсчета минимального и максимального значения в каждой группе. В качестве параметра эти методы принимают функцию 
компаратора, которая нужна для сравнения значений. Например, найдем для каждой компании телефон с минимальной ценой:


Map<String, Optional<Phone>> phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany, 
                Collectors.minBy(Comparator.comparing(Phone::getPrice))));
         
for(Map.Entry<String, Optional<Phone>> item : phonesByCompany.entrySet()){
 
    System.out.println(item.getKey() + " - " + item.getValue().get().getName());
}

----------------------------------------------


Методы summarizingInt() / summarizingLong() / summarizingDouble() позволяют объединить в набор значения соответствующих типов:


 
 Map<String, IntSummaryStatistics> priceSummary = phoneStream.collect(
    Collectors.groupingBy(Phone::getCompany,
        Collectors.summarizingInt(Phone::getPrice)));
         
for(Map.Entry<String, IntSummaryStatistics> item : priceSummary.entrySet()){
 
    System.out.println(item.getKey() + " - " + item.getValue().getAverage());
}


Метод Collectors.summarizingInt(Phone::getPrice)) создает набор, в который помещаются цены для всех телефонов каждой из групп. Данный 
набор инкапсулируется в объекте IntSummaryStatistics. Соответственно если бы мы применяли методы summarizingLong() или summarizingDouble(),
 то соответственно бы получали объекты LongSummaryStatistics или DoubleSummaryStatistics.

У этих объектов есть ряд методов, который позволяют выполнить различные атомарные операции над набором:

getAverage(): возвращает среднее значение

getCount(): возвращает количество элементов в наборе

getMax(): возвращает максимальное значение

getMin(): возвращает минимальное значение

getSum(): возвращает сумму элементов

accept(): добавляет в набор новый элемент

В данном случае мы получаем среднюю цену смартфонов для каждой группы.

Консольный вывод:

Google - 500.0
Apple - 525.0
Samsung - 390.0


-----------------------------------------------------------


Метод mapping
Метод mapping позволяет дополнительно обработать данные и задать функцию отображения объектов из потока на какой-нибудь другой тип данных. 
Например:

Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000));

Map<String, List<String>> phonesByCompany = phoneStream.collect(
    Collectors.groupingBy(Phone::getCompany,
        Collectors.mapping(Phone::getName, Collectors.toList())));
         
for(Map.Entry<String, List<String>> item : phonesByCompany.entrySet()){
 
    System.out.println(item.getKey());
    for(String name : item.getValue()){
        System.out.println(name);
    }
}
Выражение Collectors.mapping(Phone::getName, Collectors.toList()) указывает, что в группу будут выделятся названия смартфонов, причем 
группа будет представлять объект List.

Короче, идея в том, что если группировка старнартная по одному параметру в методе, то будет возвращена мапа с ключом - названием группы,
значением - лист объектов (телефонов), а если как методы выше, то значениями будут: суммы, количество повторений, среднее, мин, мах и т.п.,
а если через мапинг, то значение будет заменено на результат выполнения функции в методе мапинг.
В данно случае Map<Имя компании, Наименов. телефона>. Вот такая группировка.

То есть имя компании и не лист телефонов, а имя компании и лист имен телефонов (лист телефонов заменен на лист имен телефонов).

-----------------------------------------------------



class Optional<Tип>
{
   private final Tип value;
   private Optional() { this.value = null;}
   private Optional(value) { this.value = value;}
   public static <Tип> Optional<Tип> of(Tип value)
   {
      return new Optional<Tип>(value);
   }

   public boolean isPresent()				Проверяет, что внутри находится значение (ссылка не null)
   {
      return value != null;
   }

   public boolean isEmpty()				Проверяет, что объект хранит ссылку на null
   {
      return value == null;
   }

   public Tип get()					Возвращает значение, которое хранит. Кидает исключение, если значения нет.
   {
      if (value == null)
      {
         throw new NoSuchElementException();
      }
      return value;
   }

   public Tип orElse(Tип other)				Возвращает значение, или если внутри хранится null, то переданное в метод второе 
   {							значение
      return value != null ? value : other;
   }

   public Tип orElseThrow()				Возвращает значение или кидает исключение, если значения нет.
   {
      if (value == null)
      {
         throw new NoSuchElementException();
      }
      return value;
   }
}

-----------------------------------------------------------
Продолжение Optional в виде стрима:

Optional<String> optionalValue = Optional.of("value");
Stream<String> stream = optionalValue.map(Stream::of).orElseGet(Stream::empty);

Метод orElseGet в Java используется для получения значения из объекта Optional, если оно присутствует, или для возврата значения, 
сгенерированного вызываемым объектом Supplier, если значение отсутствует.

Мапа вернет Optional<Steram<String>>, (что странно!! Т.к. если мы передаем значения, то она возвращает измененные значения, а если 
Optional, то измененные значения, обернутые в Optional. ЧатГПТ сказал, что все так, если map принимает stream, то она будет менять его
значения, а если Optional, то внутренности этого Optional'a) т.е. Optional, метод orElseGet - это метод Optional'a и вызывается у него и 
возвращает либо значение Optional'a, т.е. сам стрим!! либо рузельтат функции в скобках - пустой стрим!! 

Через ifPersent (Consumer), кот ничего не возвращает, но обрабатывает значение Optional'a внутри себя.
Через isPresent (), кот, ничего нре принимает, а возвращает boolean продолжить поток нельзя.
------------------------------------

Метод ofNullable():
String nullableValue = null;
        Optional<String> optional = Optional.ofNullable(nullableValue);		
						
Если переданное значение равно null, то возвращаемый Optional будет пустым (empty). 
В противном случае, будет создан Optional, содержащий переданное значение.

------------------------------------

С использованием Optional					Без использования Optional
public void printString(String s)				public void printString(String s)
{								{
   Optional<String> str = Optional.ofNullable(s);		  String str = s != null ? s : "";
   System.out.println(str.orElse(""));				   System.out.println(str)
}								}

---------------------------------

Метод ifPresent() определяет действия со значением в Optional, если значение имеется:


ArrayList<Integer> numbers = new ArrayList<Integer>();
numbers.addAll(Arrays.asList(new Integer[]{4,5,6,7,8,9}));
Optional<Integer> min = numbers.stream().min(Integer::compare);
min.ifPresent(v->System.out.println(v)); // 4

В метод ifPresent передается функция, которая принимает один параметр - значение из Optional. В данном случае полученное минимальное 
число выводится на консоль. Но если бы массив numbers был бы пустым, и соответственно Optional не сдержало бы никакого значения, то 
никакой ошибки бы не было.

Метод ifPresentOrElse() позволяет определить альтернативную логику на случай, если значение в Optional отсутствует:


ArrayList<Integer> numbers = new ArrayList<Integer>();
Optional<Integer> min = numbers.stream().min(Integer::compare);
min.ifPresentOrElse(
     v -> System.out.println(v),
    () -> System.out.println("Value not found")
);

В метод ifPresentOrElse передается две функции. Первая обрабатывает значение в Optional, если оно присутствует. Вторая функция 
представляет действия, которые выполняются, если значение в Optional отсутствует.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ :: ~~~~~~~~~~~~~~~~~~~~ 

System.out::println	// для каждого элемента вызови метод println объекта printStream

4 популярных способах передачи ссылки на метод:
---------------------------------
Ссылка на метод объекта ч1

Чтобы передать ссылку на метод объекта, нужно записать код вида <Тип Объекта>::метод.
Этот код эквивалентен коду x -> объект.метод(x).

Использование синтаксиса Account::getEmail в методе map означает, что для каждого объекта типа Account в потоке будет вызван 
метод getEmail. Это эквивалентно лямбда-выражению (account) -> account.getEmail().
---------------------------------
Ссылка на метод объекта ч2

Чтобы передать ссылку на метод объекта, нужно записать код вида объект::метод.
Этот код эквивалентен коду x -> объект.метод(x).

В качестве объекта могут фигурировать такие специальные переменные как this и super.
---------------------------------
Ссылка на метод класса ч1

Чтобы передать ссылку на статический метод, нужно записать код вида класс::метод. 
Этот код будет преобразован к коду вида x -> класс.метод(x);

---------------------------------
Ссылка на конструктор

Конструктор по своему поведению чем-то похож на статический метод класса, поэтому на него тоже можно передать ссылку. Выглядит это так: класс::new.

Например, можно обойти стирание типов у коллекций и передать в метод toArray() ссылку на конструктор, который создаст нужный массив: toArray( int[]::new );

Будет преобразован в (для каждого объекта) a -> new <Class name>(a);
---------------------------------


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ЛЯМБДА-ВЫРАЖЕНИЕ ~~~~~~~~~~~~~~~~~~~~ с 8 Java

Лямбда выражение возвращает значение в виде ссылки на объект анонимного класса с переопределенным методом. Может использоваться как 
самостоятельно:

Runnable runnable = () -> System.out.println("Hello from lambda!");
(переопределили метод run() функц интерфейса Runnable,

так и в методе, ожидающим на вход объект типа функц интерфейса:
Collections.sort(list, (obj1, obj2) -> obj1.length() - obj2.length());
(интерфейс Comporator явл функц интерфейсом, поэтому поддерживает такую фишку как лямбда)

Метод, получивший лямбда-объект вызывает у него метод функц интерфейса (он ведь имеет название в самом интерфейсе) и вызывается
наш переопределенный метод.

Если метод должен что-то вернуть, мы можем написать нашу реализацию + возвр. значение: () -> {sout; return 1;}, а можно просто сразу 
вернуть значение () -> 1;

-----------------------------------------------

Для того, что бы интерфейс считался функциональным, он должен содержать только один метод (абстрактный (по умолчанию) разумеется).
Для такого интерфейса можно использоваться аннотацию @FunctionalInterface. При этом функц интерфейс может содержать default методы.

Лямбда выражение на примере функционального интерфейса с единственным абстрактным методом переопределяет этот метод интерфейса.
Почему именно этого (ведь интерфейсов может быть много таких)? Потому что то, куда мы передаем переопределенный через лямбду метод
получает объект класса интерфейс (по названию).

Короткий вариант написания: s -> s.avgGrade > 6.0 подходит, только если в интерфейсе только один параметр, если более пишем оба
параметра в скобках: (s, i) -> s.avgGrade > 6.0 && i > 0

Если в правой части выражения вы пишете более одного выражения (несколько действий), то нужно использовать полный тип написания справа:
s -> {sout ("hello!"); return s.avgGrade > 6.0;}

Если переопределяеный метод не принимает значения, а только возвращает (int например), используем следующий стиль:
() -> 18

Можно присвоить переменной типа интерфейса лямбдя-выражение (объект, переопределяющий метод):
StudentChecks sc = s -> s.avgGrade > 6.0;


В лямбда выражении параметр стрелка разделяет параметры (слева) и тело метода (справа).

public class StudentInfo {
    static void testStudents(ArrayList<Student> al, StudentChecks sc) {
        for (Student s : al)
            if (sc.check(s))
                System.out.println(s);
    }
}

class Test {
    public static void main(String[] args) {
        Student st1 = new Student("Ivan", 'm', 23, 3, 8.0);
        Student st2 = new Student("Nickolay", 'm', 22, 2, 6.0);
        Student st3 = new Student("Pil", 'f', 21, 4, 9.0);
        ArrayList<Student> students = new ArrayList<>(Arrays.asList(st1, st2, st3));

        StudentInfo.testStudents(students, s -> s.avgGrade > 6.0);		// можно более полный вариант:
    }										// (Student s) -> {return s.avgGrade > 6.0;}
}

interface StudentChecks {
    public static final int i = 0;
    public abstract boolean check(Student s);
}


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ JAVA DATE TIME API ~~~~~~~~~~~~~~~~~~~~~~ 

Java Date Time API: набор классов, которые должны решить все возможные проблемы со временем.

Классов было так много, что их решили разнести по нескольким пакетам:

Пакет java.time — базовый пакет для Java Date Time API: в нем содержатся такие классы как LocalDate, LocalTime, LocalDateTime, Instant, 
Period, Duration. Все объекты этих классов — immutable: их нельзя изменить после создания.

Пакет java.time.format содержит в себе классы для форматирования времени: преобразования времени (и даты) в текстовую строку и обратно. 
Например, в нем содержится такой универсальный класс как DateTimeFormatter, который пришел на смену SimpleDateFormat.

Пакет java.time.zone содержит классы для работы с часовыми поясами (time zones). Он содержит такие классы как TimeZone и ZonedDateTime. 
Если вы пишете код для сервера, клиенты которого находятся в разных частях света, эти классы вам очень понадобятся.



--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ LOCALDATETIME ~~~~~~~~~~~~~~~~~~~~~~ 

Самый лучший класс, можно сразу получить дни / часы, не переводя в LocalDate or LocalTime, но при желании можно и перевести.

Класс LocalDateTime объединяет в себе возможности классов LocalDate и LocalTime: он хранит и дату, и время. Его объекты тоже неизменяемые, 
и его методы также аналогичны методам классов LocalDate и LocalTime.

LocalDate date = LocalDate.now();
LocalTime time = LocalTime.now();
LocalDateTime current = LocalDateTime.of(date, time);
System.out.println("Сейчас = " + current);

LocalDateTime date = LocalDateTime.of(2019, Month.MAY, 15, 12, 15, 00);
System.out.println("Сейчас = " + date);

LocalDateTime time = LocalDateTime.now();
System.out.println("Сейчас = " + time);			Сейчас = 2019-02-22T09:49:19.275039200
							Прим: При выводе на экран дата и время разделяются буквой T.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ DATETIMEFORMATTER ~~~~~~~~~~~~~~~~~~~~~~ 

DateTimeFormatter dtf = DateTimeFormatter.ofPattern(шаблон);

DateTimeFormatter dtf = DateTimeFormatter.ofPattern("MM-dd-yy");
String text = dtf.format( LocalDateTime.now() );
System.out.println(text);						//  02-22-19

3. Полная таблица шаблонов
Полная таблица достаточно большая и очень интересная:

Шаблон	Вариации шаблона		Пример			Описание
y	yy, yyyy			19; 2019		Год
M/L	M, MM, MMM, MMMM, MMMMM		1; 01; Jan; January; J	Месяц
d	d, dd				9; 09			День
H	H, HH				2; 02			Часы
m	m, mm				3; 03			Минуты
s	s, ss				5; 05			Секунды
S	S, SS, SSS, ...			1; 12; 123		Тысячные доли секунды
n	n				123456789		Наносекунды
G	G, GGGG, GGGGG			AD; Anno Domini; A;	Эра
Q/q	q, qq, qqq, qqqq		3; 03; Q3; 3rd quarter	Квартал
w	w				13			Неделя года
W	W				3			Неделя месяца
E	EEE, EEEE, EEEEE		Mon; Monday; M		День недели
e/c	e, ee, eee, eeee, eeeee		1; 01; Mon; Monday; M	День недели
a	a				PM			AM или PM
h	h				12			Время 1-12 часов.
V	VV				Europe/Helsinki		Временная зона
z	z zzzz				EET;  Eastern European Standard Time	Временная зона
O	O OOOO				GMT+2;  GMT+02:00	Временная зона

В паттерне можно ставить свои точки, тире и т.п.:
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("d.mm.yyyyг. Hч.mмин.");
System.out.println(dtf.format(localDateTime));						// 1.24.2024г. 17ч.24мин.

----------------------------------------------

4. Парсинг времени DateTimeFormatter

DateTimeFormatter dtf = DateTimeFormatter.ofPattern("MMMM-dd-yyyy", Locale.ENGLISH);
LocalDate date = LocalDate.parse("February-23-2019", dtf);
System.out.println(date);						//  February-23-2019


Сначала мы создаем объект DateTimeFormatter и задаем в нем шаблон парсинга.

Затем вызываем метод LocalDate.parse() или LocalTime.parse() или LocalDateTime.parse() и передаем в этот метод строку, которую нужно 
распарсить и объект DateTimeFormatter, который понимает, как и по какому шаблону нужно распарсивать переданный текст.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ LOCALTIME ~~~~~~~~~~~~~~~~~~~~~~ 

Класс LocalTime очень похож на класс LocalDate: его объекты тоже нельзя изменять после создания.

LocalTime time = LocalTime.now(); - текущее время

Получение заданного времени
Чтобы получить заданное время, нужно воспользоваться статическим методом of(). Пример:

LocalTime time = LocalTime.of(часы, минуты, секунды, наносекунды); - мы задаем время
В который можно передать соответственно часы, минуты, секунды и наносекунды.

Пример:

Код						Вывод на экран
LocalTime time = LocalTime.of(12, 15, 0, 100);
System.out.println("Сейчас = " + time);		Сейчас = 12:15:00.000000100


Есть, кстати, еще две модификации этого метода:

LocalTime time = LocalTime.of(часы, минуты, секунды);

LocalTime time = LocalTime.of(часы, минуты);
Так что можете пользоваться каким вам удобнее.


Также можно получить время по номеру секунды в сутках: для этого есть специальный статический метод ofSecondOfDay():

LocalTime time = LocalTime.ofSecondOfDay(секунды);
Где секунды — это количество секунд, прошедшее с начала суток.

Пример:

Код							Вывод на экран
LocalTime time = LocalTime.ofSecondOfDay(10000);
System.out.println(time);				02:46:40
Да,10 тысяч секунд — это чуть меньше трех часов. Все верно.

-----------------------------------------------------------------

Получение фрагментов времени
Чтобы из объекта LocalTime получить значение определенного элемента времени, используют специальные методы:

Метод		Описание
int getHour()	Возвращает часы
int getMinute()	Возвращает минуты
int getSecond()	Возвращает секунды
int getNano()	Возвращает наносекунды
Пример:

Код					Вывод на экран
LocalTime now = LocalTime.now();
System.out.println(now.getHour());	2
System.out.println(now.getMinute());	46
System.out.println(now.getSecond());	40
System.out.println(now.getNano());	0

--------------------------------------------------

Изменение времени в объекте класса LocalTime
Класс LocalTime также содержит методы, которые позволяют работать со временем. Эти методы реализованы по аналогии с методами класса 
LocalDate: каждый из них не меняет существующий объект LocalTime, а возвращает новый с нужными данными.

Вот какие методы есть у класса LocalTime:

Метод				Описание
plusHours(int hours)		Добавляет часы
plusMinutes(int minutes)	Добавляет минуты
plusSeconds(int seconds)	Добавляет секунды
plusNanos(int nanos)		Добавляет наносекунды
minusHours(int hours)		Вычитает часы
minusMinutes(int minutes)	Вычитает минуты
minusSeconds(int seconds)	Вычитает секунды
minusNanos(int nanos)		Вычитает наносекунды

Пример:

Код						Вывод на экран
LocalTime time = LocalTime.now();
LocalTime time2 = time.plusHours(2);
LocalTime time3 = time.minusMinutes(40);
LocalTime time4 = time.plusSeconds(3600);

System.out.println(time);			10:33:55.978012200	
System.out.println(time2);			12:33:55.978012200
System.out.println(time3);			09:53:55.978012200
System.out.println(time4);			11:33:55.978012200

Обратите внимание, что каждый раз мы получаем новое время относительно первого объекта time. Если добавить ко времени 3600 секунд, 
это будет ровно 1 час.


!!ПРИМЕЧЕНИЕ!! Можно получить максимально и минимально возможное время:
    static LocalTime timeMax = LocalTime.MAX;
    static LocalTime timeMin = LocalTime.MIN;
--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ LOCALDATE ~~~~~~~~~~~~~~~~~~~~~~ 

Первый и самый полезный класс из Date Time API, который мы изучим — это класс LocalDate.
Объекты этого класса не изменяются после создания (класс LocalDate immutable).
Месяца номеруются с 1 (январь).

Чтобы получить текущую дату, нужно воспользоваться статическим методом now(). Это гораздо проще, чем кажется:

LocalDate today = LocalDate.now();

-----------------------------------------

Также у класса LocalDate есть разновидность метода now(ZoneId), который позволяет получить текущую дату в определенном часовом поясе.

Для этого нам понадобится еще один класс — ZoneId (java.time.ZoneId). У него есть метод of(), который возвращает объект ZoneId по имени 
часового пояса.

Чтобы определить текущую дату в Шанхае, нужно написать код:

Код							Вывод на экран
ZoneId  timezone = ZoneId.of("Asia/Shanghai");
LocalDate today = LocalDate.now(timezone);
System.out.println("Сейчас в Шанхае = " + today);	Сейчас в Шанхае = 2019-02-22

Список имен всех часовых поясов (time zone) можно найти в интернете.

----------------------------------------

Получение конкретной даты
Чтобы получить объект LocalDate, содержащий определенную дату, нужно воспользоваться статическим методом of(). Выглядит все тоже очень 
просто и понятно:

LocalDate date = LocalDate.of(2019, Month.FEBRUARY, 22);
Где date — это переменная класса LocalDate, а LocalDate.of() — вызов статического метода of() у класса LocalDate.

Также тут мы видим использование специальной константы FEBRUARY класса Month (java.time.Month) для задания месяца Февраль.

Можно задать месяц и по старинке — с помощью числа:

LocalDate date = LocalDate.of(2019, 2, 22);

--------------
Есть еще один любопытный метод создания даты: с помощью метода ofYearDay можно получить дату, имея только номер года и номер дня года. 
Общий вид такой:

LocalDate date = LocalDate.ofYearDay(год, день);
Где год — это номер года, а день — номер дня в году.

Код							Вывод на экран
LocalDate today = LocalDate.ofYearDay(2019, 100);
System.out.println("Сегодня = " + today);		Сегодня = 2019-04-10


-------------------------------------------------------------

Получение фрагментов даты
Изменять объекты класса LocalDate нельзя, а вот получать отдельные фрагменты даты еще как можно. Для этого у объектов класса LocalDate 
есть несколько методов:

Метод				Описание
int getYear()			Возвращает год из конкретной даты
Month getMonth()		Возвращает месяц даты — одну из специальных констант
				JANUARY, FEBRUARY, ...;
int getMonthValue()		Возвращает номер месяца из даты. Январь == 1.
int getDayOfMonth()		Возвращает номер дня в месяце
int getDayOfYear()		Возвращает номер дня с начала года
DayOfWeek getDayOfWeek()	Возвращает день недели: одну из специальных констант
				MONDAY, TUESDAY, ...;
IsoEra getEra()			Возвращает эру: константа BC (Before Current Era) и CE(Current Era)

Код						Вывод на экран
LocalDate today = LocalDate.now();
System.out.println(today.getYear());		2019
System.out.println(today.getMonth());		FEBRUARY
System.out.println(today.getMonthValue());	2
System.out.println(today.getDayOfMonth());	22
System.out.println(today.getDayOfWeek());	FRIDAY


-------------------------------------------------------------------

Изменение даты в объекте LocalDate
Класс LocalDate содержит несколько методов, которые позволяют работать с датой. Эти методы реализованы по аналогии с методами класса 
String: каждый из этих методов не меняет существующий объект LocalDate, а возвращает новый с нужными данными.

Вот какие методы есть у класса LocalDate:

Метод				Описание
plusDays(int days)		Добавляет определенное количество дней к дате
plusWeeks(int weeks)		Добавляет недели к дате
plusMonths(int months)		Добавляет месяцы к дате
plusYears(int years)		Добавляет годы к дате
minusDays(int days)		Отнимает дни от даты
minusWeeks(int weeks)		Отнимает недели от даты
minusMonths(int months)		Отнимает месяцы от даты
minusYears(int years)		Отнимает годы от даты
Пример:

Код							Вывод на экран
LocalDate birthday = LocalDate.of(2019, 2, 28);
LocalDate nextBirthday = birthday.plusYears(1);
LocalDate firstBirthday = birthday.minusYears(30);

System.out.println(birthday);				2019-02-28
System.out.println(nextBirthday);			2020-02-28
System.out.println(firstBirthday);			1989-02-28


Объект birthday, чьи методы мы вызываем, не меняется. Вместо этого его методы возвращают новые объекты, которые и содержат нужные данные.

Прим!!! ВЫВЕСТИ ДЕНЬ НЕДЕЛИ ПО-РУССКИ:
        return date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.forLanguageTag("ru"));


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ CALENDAR ~~~~~~~~~~~~~~~~~~~~~~ 


Calendar date = Calendar.getInstance();

Теперь date содержит актуальный календарь. Дело в том, что на Земле не один, а много календарей. И почти каждый из них связан с 
какой-нибудь религией или страной. Класс Calendar поддерживает 3 из них:

Календарь			Описание
GregorianCalendar		Христианский Григорианский календарь
BuddhistCalendar		Буддистский календарь
JapaneseImperialCalendar	Японский Императорский календарь

Объект календарь с произвольной датой создается командой:

Calendar date = new GregorianCalendar(год, месяц, день);

Год нужно писать полностью: никаких 19 вместо 2019. Месяцы по-прежнему нумеруются с нуля. А дни месяца по-прежнему нумеруются не с нуля 
(слабаки!).

Чтобы задать не только дату, но и время, нужно передать их дополнительными параметрами:

... = new GregorianCalendar(год, месяц, день, часы, минуты, секунды);


Правильно будет отображать объект календарь с помощью класса SimpleDateFormat, но пока мы его не изучили, можно использовать лайфхак.

Date date = calendar.getTime();

Дело в том, что объект типа Calendar можно легко преобразовать к объекту типа Date, а как выводить на экран объект типа Date, вы уже 
знаете (с помощью SimpleDateFormat или просто sout).

---------------------------------

Работа с фрагментами даты
Чтобы получить фрагмент даты (год, месяц, ...), у класса Calendar есть специальный метод — get(). Метод один, зато с параметрами:

int month = calendar.get(Calendar.MONTH);
Где calendar — это переменная типа Calendar, а MONTH — это переменная-константа класса Calendar.

В метод get в качестве параметра вы передаете специальную константу класса Calendar, и в результате получаете нужное значение.

Примеры

Код							Описание
Calendar calendar = Calendar.getInstance();

int era = calendar.get(Calendar.ERA);			эра (до нашей эры или после)
int year = calendar.get(Calendar.YEAR);			год
int month = calendar.get(Calendar.MONTH);		месяц		
int day = calendar.get(Calendar.DAY_OF_MONTH);		день месяца

int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);	день недели
int hour = calendar.get(Calendar.HOUR);			часы
int minute = calendar.get(Calendar.MINUTE);		минуты
int second = calendar.get(Calendar.SECOND);		секунды


Для изменения фрагмента даты используется метод set:

calendar.set(Calendar.MONTH, значение);
Где calendar — это переменная типа Calendar, а MONTH — это переменная-константа класса Calendar.

В метод set в качестве первого параметра вы передаете специальную константу класса Calendar, а в качестве второго параметра — новое 
значение.

Примеры

Код							Описание
Calendar calendar = new GregorianCalendar();

calendar.set(Calendar.YEAR, 2019);			год = 2019
calendar.set(Calendar.MONTH, 6);			месяц = Июль (нумерация с 0)
calendar.set(Calendar.DAY_OF_MONTH, 4);			4 число
calendar.set(Calendar.HOUR_OF_DAY, 12);			часы
calendar.set(Calendar.MINUTE, 15);			минуты
calendar.set(Calendar.SECOND, 0);			секунды

System.out.println(calendar.getTime());

---------------------------------------------

5. Константы класса Calendar
В классе Calendar есть константы не только для названия фрагментов даты, а кажется, на все случаи жизни.

Calendar date = new GregorianCalendar(2019, Calendar.JANUARY, 31);

Есть константы для обозначения месяцев или, например, для дней недели:

Calendar calendar = new GregorianCalendar(2019, Calendar.JANUARY, 31);
if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY)
{
   System.out.println("Это пятница");
}
Всего перечислять не будем. Просто хотим, чтобы вы не удивлялись, если встретите такие записи в коде.

Использование констант позволяет сделать код более читабельным, поэтому программисты их и добавили. Ну а месяцы нумеруются с нуля тоже 
ради читабельности. Или нет.

---------------------------------------------

6. Изменение даты в объекте Calendar
У класса Calendar есть метод, который позволяет проводить с датой более умные операции. Например, добавить к дате год, месяц или несколько 
дней. Или отнять. Называется этот метод add(). Выглядит работа с ним примерно так:

calendar.add(Calendar.MONTH, значение);
Где calendar — это переменная типа Calendar, а MONTH — это переменная-константа класса Calendar.

В метод add в качестве первого параметра вы передаете специальную константу класса Calendar, и в качестве второго параметра — значение, 
которое нужно добавить.

Особенность этого метода в том, что он умный. Давайте сами посмотрим, насколько:

Код
Calendar calendar = new GregorianCalendar(2019, Calendar.FEBRUARY, 27);
calendar.add(Calendar.DAY_OF_MONTH, 2);
System.out.println(calendar.getTime());
Вывод на экран
Fri Mar 01 00:00:00 EET 2019
Этот метод понимает, что в феврале 2019 года всего 28 дней, и итоговая дата — 1 марта.

А теперь давайте отнимем 2 месяца! Что должно получиться? 27 декабря 2018 года! Сейчас проверим.

Чтобы выполнить действие, уменьшающее дату, нужно в метод add() передать значение с отрицательным знаком:

Код
Calendar calendar = new GregorianCalendar(2019, Calendar.FEBRUARY, 27);
calendar.add(Calendar.MONTH, -2);
System.out.println(calendar.getTime());
Вывод на экран
Thu Dec 27 00:00:00 EET 2018
Работает!

Этот метод учитывает длины месяцев и високосные годы. В общем, отличный метод. Именно то, что нужно большинству программистов, которые 
плотно работают с датами.

-------------------------------------------

Прокручивание фрагментов даты
Но иногда бывают ситуации, когда такое умное поведение излишне: хочется что-то сделать с одной частью даты, не меняя все остальное.

Для этого у класса Calendar есть специальный метод — roll(). По своей сигнатуре он полностью аналогичен методу add(), но любые изменения 
с его помощью затрагивают один параметр, остальные остаются неизменными.

Пример:

Код
Calendar calendar = new GregorianCalendar(2019, Calendar.FEBRUARY, 27);
calendar.roll(Calendar.MONTH, -2);
System.out.println(calendar.getTime());
Вывод на экран
Fri Dec 27 00:00:00 EET 2019
Месяц мы поменяли, а год и число остались неизменными.


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ DATE ~~~~~~~~~~~~~~~~~~~~~~ 

Date current = new Date();
System.out.println(current);		// Thu Feb 21 14:01:34 EET 2019

---------------------------------

Задание даты:
Date birthday = new Date(год, месяц, день); 
Год нужно задавать от 1900.
Месяцы нумеруются с нуля.

Например, я родился 21 марта 1989 года. Март — третий месяц, значит мне нужно написать:

Код						Вывод на экран
Date current = new Date(89, 2, 21);
System.out.println(current);			Tue Mar 21 00:00:00 EET 1989

---------------------------------

Задание определенного времени

Задать определенное время тоже достаточно просто: для этого нужно написать команду вида:

Date birthday = new Date(год, месяц, день, час, минуты, секунды);			// год задается с 1900
Часы, минуты и секунды нумеруются с нуля: программист внутри вас должен вздохнуть спокойно.

Пример:

Код							Вывод на экран
Date current = new Date(105, 5, 4, 12, 15, 0);
System.out.println(current);				Sat Jun 04 12:15:00 EEST 2005

-------------------------------------

Работа с фрагментами даты
Объект Date можно не просто выводить на экран. У него есть методы, которые позволяют получить отдельные фрагменты его даты:

Метод				Описание
int getYear()			Возвращает год даты относительно 1900 года.
int getMonth()			Возвращает месяц даты, месяцы нумеруются с нуля
int getDate()			Возвращает день месяца
int getDay()			Возвращает день недели
int getHours()			Возвращает часы
int getMinutes()		Возвращает минуты
int getSeconds()		Возвращает секунды
Пример:

Код							Вывод на экран		Примечание
Date current = new Date(105, 5, 4, 12, 15, 0);		
System.out.println(current.getYear());			105
System.out.println(current.getMonth());			5
System.out.println(current.getDate());			4
System.out.println(current.getDay());			6			6й день недели - суббота


Кстати, у объекта Date отдельные фрагменты даты можно не только получать, но и изменять:

Метод				Описание
void setYear(int year)		Меняет год даты. Год задаётся относительно 1900 года.
void setMonth(int month)	Меняет месяц даты, месяцы нумеруются с нуля
void setDate(int date)		Меняет день месяца
void setHours(int hours)	Меняет часы
void setMinutes(int minutes)	Меняет минуты
void setSeconds(int seconds)	Меняет секунды

----------------------------------------------

Миллисекунды
Как мы уже говорили, внутри объекта Date хранится количество миллисекунд, прошедшее с 1 января 1970 года.

Если оно нам нужно, мы можем получить его у объекта Date:

long time = date.getTime();
Метод getTime() 		возвращает количество миллисекунд, которое хранится внутри объекта Date.

Вы можете не просто получить количество миллисекунд, но и изменить его в существующем объекте:

Date date = new Date();
date.setTime(1117876500000L);
Кстати, можно записать эту конструкцию короче, передав время в объект Date прямо во время его создания:

Date date = new Date(1117876500000L);

-------------------------------------------

Сравнение дат
Если вы хотите сравнить две даты и узнать, какая из них была раньше, для этого есть три способа

Способ первый — просто сравнить количество миллисекунд, которое в них хранится:

if (date1.getTime() < date2.getTime())
Способ второй — использовать метод before() объекта Date:

if (date1.before(date2))
Читается это так: если date1 перед date2, то...

Способ третий — использовать метод after() объекта Date:

if (date2.after(date1))
Читается это так: если date2 после date1, то...

-----------------------------------------------

Класс DateFormat
Помните, когда мы выводили дату на экран, отображалось что-то типа Thu Feb 21 14:01:34 EET 2019. Вроде бы все правильно, но это скорее 
отображение даты для программиста. А для пользователя хотелось бы отображать дату попонятнее. Что-нибудь типа Вторник, 21 Февраля.

И без года. Ну или с годом, если надо. В общем, хотелось бы отображать дату разными способами.

Для этого есть специальный класс — SimpleDateFormat.

Пример:

Код
Date current = new Date(105, 5, 4, 12, 15, 0);					Вывод на экран
SimpleDateFormat formatter = new SimpleDateFormat("MMM-dd-YYYY");
String message = formatter.format(current);
System.out.println(message);							Jun-04-2005					


Видите, что программа вывела на экран: Jun-04-2005. Совсем не то, что раньше.

А все дело в том, что мы отображали не сам объект Date, а специальную строку, полученную вызовом метода format() у объекта типа 
SimpleDateFormat. Но ключевое здесь даже не это.

Когда объект SimpleDateFormat создается, в него в виде параметров мы передаем строку "MMM-dd-YYYY". Вот в этой строке и зашифрован формат 
даты, который вы увидели в итоге на экране.

EEEE - день недели в формате полного слова https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/SimpleDateFormat.html
MMM значит вывести название месяца, сокращенное до трех букв
dd — вывести день месяца
YYYY — вывести год, состоящий из четырех цифр
Если мы хотим вывести месяц в виде цифр, нужно вместо MMM написать MM: получится строка "MM-dd-YYYY". На экран будет выведено 06-04-2005

SimpleDateFormat:
Символ	Значение	Представление	Пример
G	обозначение эры	Текст	AD, н.э.
y или yyyy	год (4 цифры)	Число	2017
yy	год (2 последние цифры)	Число	17
M	номер месяца без лидирующих нулей	Число	1, 11
MM	номер месяца дополненный нулями	Число	01, 11
MMM	сокращенное название месяца	Текст	дек, Dec
MMMM	полное название месяца (контекстно-зависимое)	Текст	декабря, December
LLLL	полное название месяца (контекстно-независимое)	Текст	Декабрь, December
w	неделя в году	Число	13
W	неделя в месяце	Число	3
D	день в году	Число	172
d	день месяца	Число	11
F	день недели в месяце	Число	1
E	сокращенное название дня недели	Текст	Ср, Wed
EEEE	полное название дня недели	Текст	среда, Wednesday
u	номер дня недели (1-пн .. 7-вск)	Число	3
a	маркер am/pm	Текст	AM
H	Час в дне (0-23)	Число	0
h	Часы в am/pm (1-12)	Число	12
K	час в am/pm (0-11)	Число	0
k	час в дне (1-24)	Число	24
m	минута в часе	Число	18
s	секунда в минуте	Число	35
S	миллисекунды	Число	978
z	часовой пояс	Текст	GMT+07:00
Z	часовой пояс в формате RFC 822	Текст	700
X	часовой пояс в формате ISO 8601	Текст	7


SimpleDateFormat dateFormat = new SimpleDateFormat("EEEE", new Locale("ru", "RU"));
В конструктор мы допом передаем Locale в параметрами локации типа вывода.

------------------------------------------------------

8. Метод Date.parse
Класс Date умеет делать еще одну интересную и полезную вещь: получать дату из текстовой строки. Или как говорят программисты, парсить 
строку.

Для этого у него есть специальный метод — parse(). Выглядит процесс парсинга так:

Date date = new Date();
date.setTime( Date.parse("Jul 06 12:15:00 2019") );
Кстати, этот же код можно записать более компактно:

Date date = new Date("Jul 06 12:15:00 2019");
Более подробно парсинг строк мы разберем в других лекциях.

------------------------------------------------


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ RandomAccessFile ~~~~~~~~~~~~~~~~~~~~~~ 

В Java RandomAccessFile — это класс в пакете java.io, который предоставляет механизм для случайного чтения и записи в файл, в отличие от 
последовательного доступа, предоставляемого другими классами файлового ввода-вывода. Этот класс позволяет перемещать указатель на файл в 
любое место в файле и выполнять операции чтения или записи в этом конкретном месте.

public class RandomAccessFile
   extends Object
      implements DataOutput, DataInput, Closeable

Конструкторы:
RandomAccessFile(File fileObj, String mode)
RandomAccessFile(String fileName, String mode)

Инициализация:

RandomAccessFile file = new RandomAccessFile("data.txt", "rw");

Доступы:
- в режиме чтения ("r") 
- чтения/записи ("rw"). 
- режим "rws", когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое 
устройство.


Методы:
- write()				записывает байт данных в файл в ТЕКУЩЕЙ позиции указателя файла 
						file.write(65); //writes the ASCII code for 'A' to the file
- writeBytes()				записывает строку данных в файл в ТЕКУЩЕЙ позиции указателя файла
						file.writeBytes("Hello World");
-  writeChar()				записывает символ в файл в текущей позиции указателя файла
						file.writeChar('A');
- writeInt() 				метод отвечает за запись целого числа в файл в текущей позиции указателя файла
						file.writeInt(42);
- writeDouble()

- getFilePointer()			- возвращает текущий указатель файла (позицию, где он находится)

- seek()				метод используется для установки позиции указателя файла в указанное место в файле
					Позиция измеряется в байтах от начала файла
						file.seek(10);
- read()				считывает байт данных из файла в текущей позиции

- readBytes()				считывает строку данных из файла в текущей позиции

- readInt(), readDouble()		- см. что читает (там список полный)

- readUTF()				- считать строку в формате UTF

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ЛОГИРОВАНИЕ ~~~~~~~~~~~~~~~~~~~~ https://russianblogs.com/article/859092735/

Логгер всегда передает инфо наверх, если у родителя есть consoleHandler, сообщение выведется дважды.
То есть у логгера нет своего хэндлера по умолчанию, выводит родительский. 
Если добавить логгеру консольхэндлер, выведет и родительский и свой. А если добавить наследнику нашего логгера, то трижды.

Можно через PrintStream:
// Определяем файл в который будем писать лог
        System.setErr(new PrintStream(new File("d:\\log3.txt")));		// in this case nothing will be written on the console
// Выводим сообщения								screen - all will be written in file
        System.err.println("Сообщение 1");
        System.err.println("Сообщение 2");
// Выводим сообщение об ошибке
        try {
            throw new Exception("Сообщение об ошибке");
        } catch (Exception e) {
            e.printStackTrace();
        }
--------------------------------------------------------------------------------
А можно через JUL:

Logger logger = Logger.getLogger(MyClass.class.getName());		// можно указать любое имя, но положено имя класса

Обычно делают private static final Logger logger = Logger.getLogger(MyClass.class.getName());

Можно вывести сообщение двумя способами:
        logger.log(Level.INFO, "Сообщение с уровнем INFO");
        logger.info("info");

Уровни журналов используются для классификации их по степени серьезности или влиянию на стабильность приложения. 
Пакет java.util.logging предоставляет следующие уровни в порядке убывания:

SEVERE (Самый строгий уровень);

WARNING;

INFO;

CONFIG;

FINE;

FINER;

FINEST

Для того, чтобы установить для логгера определенный уровень логирования используется метод setLevel():
logger.setLevel(Level.WARNING);

Логгер будет регистрировать события указанного уровня и всех уровней выше (логгер из примера будет регистрировать события уровней 
WARNING и SEVERE)

----------------------------------

Java SE реализует 5 обработчиков (Handlers):

(1) java.util.logging.ConsoleHandler выводит журналы в System.err.

(2) java.util.logging.FileHandler выводит информацию в файл.

(3) java.util.logging.! StreamHandler выводит журналы с указанным экземпляром! OutputStream.

(4) java.util.logging.! SocketHandler передает информацию на удаленный хост через сокет.

(5) java.util.logging.! MemoryHandler временно сохраняет информацию в памяти.

---------------------------------

public static void main(String[] args) {
        Logger logger = Logger.getLogger("LoggingDemo");
        logger.setLevel(Level.ALL); // по-умолчанию INFO
										// данный логгер будет писать на экран и в файл
        try {									   одновременно. Если не писать на экран, нужно отключить
            FileHandler fileHandler = new FileHandler("D:\\log4.txt");			родительские handler's:
// можно написать Handler fileHandler = new FileHandler("D:\\log4.txt");		logger.setUseParentHandlers(false);
// or Handler fileHandler = new ConsoleHandler();
            fileHandler.setLevel(Level.ALL);					
            logger.addHandler(fileHandler);					
            logger.info("Тестовая информация");
            logger.log(Level.INFO, "log");
            logger.logp(Level.SEVERE, MyClass.class.getName(), "main", "full info");

----------------------------------------------------------------------------

ФОРМАТТЕР:

java.util.logging.SimpleFormatter: Стандартный формат журнала. формат ConsolerHandler по умолчанию - java.util.logging.SimpleFormatter.

java.util.logging.XMLFormatter: Формат журнала в формате XML. FileHandler по умолчанию является java.util.logging.XMLFormatter.
Вы можете использовать метод setFormatter () экземпляра Handler для установки вывода информации. формат. Например:
fileHandler.setFormatter(new SimpleFormatter());

Можно сделать свой форматтер. Например, мы хотим что бы не выводилось время, класс, метод, а только уровень и сообщение:

	logger.setUseParentHandlers(false);
        FileHandler fileHandler = new FileHandler("D:\\log4.txt");
        Handler consoleHandler = new ConsoleHandler();

        logger.addHandler(consoleHandler);
        logger.addHandler(fileHandler);

        consoleHandler.setFormatter(new MyFormatter());

static class MyFormatter extends Formatter {

        @Override
        public String format(LogRecord record) {
            return record.getLevel() + ": " + record.getMessage() + "\n";
        }
    }

--------------------------------------------------------------------------

ФИЛЬТРЫ:

Можно выбрать, что будет записываться в файл / на экран. Например, мы хотим логить только те сообщения, которые заканчиваются на "1":

public static void main(String[] args) {
        Logger logger = Logger.getLogger(MyClass.class.getName());
        logger.setFilter(new MyFilter());
        logger.info("ytfyu");
        logger.info("kjygfjht1");

    }
    static class MyFilter implements Filter {

        @Override
        public boolean isLoggable(LogRecord record) {
            return record.getMessage().endsWith("1");
        }
    }

Или, например, только то, что INFO:
return record.getLevel().getName().equals("INFO");

--------------------------------------------------

Если мы хотим обойтись без конактенации строк в длинном сообщении логера:

String[] strings = {mailMessage.from, mailMessage.to, mailMessage.getMessage()};
logger.log(Level.WARNING, "Detected target mail correspondence: from {0} to {1} \"{2}\"", strings);

---------------------------------------------------

Если нужно получить распечатку стек-трейса исключения:
logger.log(Level.WARNING, "Exception detected", e);

Ответы на вопросы:
Почему логер именуется именем класса?
- Потому, что так каждый класс получает свой индивидуальный логгер. Возможно управлять настройками логирования с точностью до класса.
для одного класса логирование включено, для другого - выключено.
- Логгеры выстраиваются в иерархию в соотв с именами.


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ SOLID ~~~~~~~~~~~~~~~~~~~~

S - Принцип единственной ответственности, Single Responsibility Principle
-------------------------------------------------------------------------
Через ваш класс должна проходить только одна ось изменений, т.е. ваш класс должен меняться только по одной причине. Добиться этого
можно тем, что ваш класс содержит только поля и методы, относящиеся к одному вопросу. Если вы работаете 
на проекте более 6 мес, вы точно можете сказать, что вот эти классы постоянно меняются - это называется ось изменений. 
Программисты говорят: "Ось изменений проходит через эти классы". Т.е. если нам нужно работать с временем и температурой, не нужно
запихивать все в один класс, раздели на два, т.к. потом Вася и Петя могут у тебя попросить код, а он смешан + при тестировании
у тебя найдут ошибки и исправят, а у них нет либо к ним по-новой.


O - OCP - Принцип открытости/закрытости (Open Closed Principle)
-------------------------------------------------------------------------
Любой класс, метод, блок программного кода должен быть открыт для расширения (добавления функциональности), но закрыт для изменения.

Смысл в том, что бы при добавлении функциональности не менять классы так, что бы в них (а они уже проверены, без багов) не появились
те самые баги и не нужно было все перетестировать. Как же добавить функциональность, не изменяя класс? Есть два способа:

1. Добавить класс наследник и в нем реализовать все новые фичи.
2. Полиморфный - клиентский код должен зависеть от интерфейса (который неизменный), а наши старый и новый классы наследоваться от 
интерфейса. Новый может так же наследоваться от старого.


L - принцип замещения (замены) LSP (The Liskov Substitution Principle)
-------------------------------------------------------------------------
В том месте программы, где используется базовый класс, должен подходить любой наследник.
. Обьекты в программе можно заменить их наследниками без изменения свойств программы.
Например у нас есть класс А (наш супер класс, родитель) и унаследованный от него класс Б (его наследник, потомок, класс который просто 
расширяет наш класс А) . И вот если мы заменим все использования класса A на Б и в поведении программы ничего не изменится, то это 
значит, что наша программа соотвсетствует принципу подстановки Барбары Лисков).
При наследовании мы не должны менять поведение родителя.
Если есть какой-то кусок кода, куда приходит базовый класс, то в этот же кусок кода должен без помех и иксепшн"ов приходить любой
его наследник.  Подкласс не может требовать от вызывающего кода больше, чем основной класс и не может возвращать меньше основного.
Тесты, справедливые для прямоугольника, должны быть праведливы для его наследников.


I - ISP (Принцип Разделения Интерфейса (The Interface Segregation Principle)
--------------------------------------------------------------------------------------------------
Клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.


D - Принцип инверсии зависимостей (DIP)
--------------------------------------------------------------------------------------------------
зависимости внутри системы строятся на основе абстракций. Программное обеспечение нужно разрабатывать так, чтобы различные модули были 
автономными и соединялись друг с другом с помощью абстракции. Классическое применение этого принципа — Spring framework.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ПОЛИМОРФИЗМ ~~~~~~~~~~~~~~~~~~~~

Полиморфизм - это возможность вариативной реализации методов в объектах, объединенных общим интерфейсом либо родителем.
+ перегрузка методов.

Если мы определяем объект типа родитель:

Animal aminal = new Dog();

то мы можем использовать только методы класса Animal + методы Animal, переопределенные в классe Dog (в этом случае вызовется 
переопределенный метод). То есть мы смотрим на собаку как на животное. Методы чисто собаки будут недоступны.


То же самое с интерфейсом:
можно использовать только методы интерфейса (собственные методы объекта недоступны).


Позднее связывание - это выбор метода в потомке, при его наличии.

Наследовать и переопределять можно только нестатические методы. Статические методы не наследуются и, следовательно, не переопределяются.
------------------------

Набор методов, которые можно вызвать у переменной, определяется типом переменной. А какой именно метод/какая реализация вызовется, 
определяется типом/классом объекта, ссылку на который хранит переменная.

Тоесть, Animal animal = new Cat(); при animal.say(); вызовется переопределенный say() в классе cat.

Тоесть нам будут доступны все методы Анимал, но если они переопределены у кошки, то вызовется ее (кошачий) метод.

-----------------------

Расширение типа:
Cow cow = new Whale(); корова - родитель

Сужение типа:
Whale whale = (Whale) cow;

Тоесть! Когда здесь идет речь не о функциональности (кол-ве доступных св-в и методов), а о ширине взляда. Если мы смотрим в общем, то - это
расширение. Если узко (конкретно), то - сужение, конкретизация.

Это нужно, для того, что бы: допустим у нас есть астронавты: кошка, собака, человек. Они входят в List austranauts и естественно, они все
явл астронавтами. Теперь нам нужно их кормить - человека - человеческой едой, собаку - собачьей и т.д. Поэтому и относиться к ним мы
будем как к конкретным типам (сужение). Для человека вызовем метод кормления человека и передадим (Human) astranout (астронавта, приведен-
ного к человеку).

-----------------------

Можно вызвать метод у родителя ч/ super.<имя метода>();

class МирноеВремя
{
   public double getPi()
   {
      return 3.14;
   }
}

class ВоенноеВремя extends МирноеВремя
{
   public double getPi()
   {
      return super.getPi()*2;  // 3.14*2
	// можно добавить какие-то свои доп. действия
   }
}

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ FINAL ~~~~~~~~~~~~~~~~~~~~

Применяется:
- для класса - нельзя наследоваться
- для конструктора - НЕ МОЖЕТ БЫТЬ FINAL, может быть private (нельзя создавать объект)
- для метода - нельзя переопределять
- для параметра метода (принятый параметр нельзя изменять в теле метода)
- для объекта - нельзя менять ссылку (но можно менять начинку, в массиве например)
- для примитива - нельзя менять значение

--------------------------------------------------------------------------------------------------
	~~~~~~~~~~~~~~~~~~~~ Класс URL (читает, как InputStream)  ~~~~~~~~~~~~~~~~~~~~

URL url = new URL("https://javarush.com");
InputStream input = url.openStream();
byte[] buffer = input.readAllBytes();
String str = new String(buffer);
System.out.println(str);

--------------------------------------------------------------------------------------------------
	~~~~~~~~~~~~~~~~~~~~ Класс URLConnection (чтение и загрузка данных ч/InputStream OutputStream) ~~~~~~~~~~~~~~~~~~~~

URL url = new URL("https://javarush.com");
URLConnection connection = url.openConnection();

// отправляем данные
try (OutputStream output = connection.getOutputStream();
   PrintStream sender = new PrintStream(output))
{
   sender.println("Привет");
}

// читаем данные
try(InputStream input = connection.getInputStream();
   BufferedReader reader = new BufferedReader(new InputStreamReader(input)))
{
   while (reader.ready())
      System.out.println(reader.readLine());
}

Твоя задача — обратиться к публичному API в интернете: отправить и получить данные.
Напиши программу, которая будет обращаться по ссылке к публичному API в интернете, отправляя туда данные, получать ответные данные и 
выводить их на экран.

    public static void main(String[] args) throws IOException {
        URL url = new URL("http://httpbin.org/post");
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);

        try (OutputStream output = connection.getOutputStream();
             PrintStream sender = new PrintStream(output)) {
            sender.println("Привет");
        }

        try (BufferedReader bf = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
            while (bf.ready()) {
                System.out.println(bf.readLine());
            }
        }
    }

----------------------------------------------
Сохранение файла на диск
String image = "https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png";
URL url = new URL(image);
InputStream input = url.openStream();

Path path = Path.of("c:\\GoogleLogo.png");
Files.copy(input, path);
----------------------------------------------


--------------------------------------------------------------------------------------------------
	~~~~~~~~~~~~~~~~~~~~ КЛАСС FILE (типа устаревший)  ~~~~~~~~~~~~~~~~~~~~

В названии пути к файлу / папке:
. - текущая директория
.. - директория назад

В Java есть специальный класс (File), с помощью которого можно управлять файлами на диске компьютера. Для того чтобы управлять содержимым 
файлов, есть другие классы: FileInputStream, FileOutputStream. Файлы можно создавать, удалять, переименовывать и еще много чего. В 
практически все классы, которые работают (читают, пишут, изменяют) с содержимым файла, можно передавать объект класса File.

Представь, что тебе нужно вывести на экран список всех файлов и папок, которые находятся в определенной директории (папке). Вот как это 
можно сделать:

File folder = new File("c:/path/");

for (File file : folder.listFiles())
	System.out.println(file.getName());
 

file[] listFiles() — это метод, который возвращает массив файлов и папок в директории с именем «c:/path/». А getName выдает имя файла/папки.


boolean isDirectory()			Является ли «объект файла» директорией

boolean isFile()			Является ли объект файлом

long length()				Возвращает размер/длину файла в байтах.

boolean createNewFile()			Создает файл. Если такой файл уже был, возвращает false.

boolean mkdir()				Создает директорию. Название mkdir происходит от "make directory".

boolean mkdirs()			Создает директорию и все поддиректории.

boolean delete()			Удаляет файл объекта на диске. Если объект – директория, то только, если в ней нет файлов.

void deleteOnExit()			Добавляет файл в специальный список файлов, которые будут автоматически удалены при закрытии 
															программы.
File createTempFile(String prefix,String suffix,File directory)

					Создает «временный файл» - файл с случайно сгенерированным уникальным именем – что-типа 
					«dasd4d53sd». Дополнительные параметры – префикс к имени, суффикс (окончание). Если директория не 
					указана, то файл создается в специальной директории ОС для временных файлов.

boolean exists()			Возвращает true, если файл с таким именем существует на диске компьютера.

String getAbsolutePath()		Возвращает полный путь файла со всеми поддиректориями.

String getCanonicalPath()		Возвращает канонический путь файла. По идее как normalize в Path. 
					Например, преобразовывает путь «c:/dir/dir2/../a.txt» к пути «c:/dir/a.txt»

String[] list()				Возвращает массив имен файлов, которые содержатся в директории, которой является текущий объект-файл.

File[] listFiles()			Возвращает массив файлов, которые содержатся в директории, которой является текущий объект-файл.

long getTotalSpace()			Возвращает размер диска (количество байт) на котором расположен файл.

long getFreeSpace()			Возвращает количество свободного места (количество байт) на диске, на котором расположен файл.

boolean renameTo(File)			Переименовывает файл – содержимое файла фактически получает новое имя. Т.е. можно переименовать 
					файл «c:/dir/a.txt» в «d:/out/text/b.doc». То есть, по сути копирует его. Не работает между
					разными дисками либо если не создана папка назначения.

String getName()			Возвращает только имя файла, без пути.

String getParent()			Возвращает только путь (директорию) к текущему файлу, без самого имени.

Path toPath()				Возвращает объект Path, который соответствует текущему объекту File.

a\b\c\file.txt
a\b\c\file.txt


--------------------------------------------------------------------------------------------------
	~~~~~~~~~~~~~~~~~~~~ КЛАСС FILES (типа не устаревший)  ~~~~~~~~~~~~~~~~~~~~

Объект Files мы не создаем. Вместо этого создаем объект Path.of("") и передаем его в Files:
Path path = Path.of("c:\\readme.txt");
List<String> list = Files.readAllLines(path);

for (String str : list)
   System.out.println(str);

Все методы этого класса статические и работают с объектами типа Path.

Методов очень много, поэтому мы рассмотрим только основные:
Path createFile(Path path)		Создает новый файл с путем path		Files.createFile(Path.of("c:\\readme.txt")); Создает файл
Path createDirectory(Path path)		Создает новую директорию		Files.createDirectory(Path.of("c:\\test"));
										Создает директорию
Path createDirectories(Path path)	Создает несколько директорий		Files.createDirectories(Path.of("c:\\test\\1\\2\\3"));
										Создает директорию и все нужные поддиректории, если их не 
										существует.
Path createTempFile(prefix, suffix)	Создает временный файл
Path createTempDirectory(prefix)	Создает временную директорию
void delete(Path path)			Удаляет файл или директорию (если она пуста)
										Path path = Path.of("d:\\readme-new.txt");
										Files.delete(path);

Path copy(Path src, Path dest)		Копирует файл				Path path1 = Path.of("c:\\readme.txt");
										Path path2 = Path.of("c:\\readme-copy.txt");
										Files.copy(path1, path2);
					Либо данные из потока сразу в файл	СМОТРИ ПЕРЕГРУЗКУ 
										Files.copy(InputStream, path);

Path move(Path src, Path dest)		Перемещает файл				Path path1 = Path.of("c:\\readme.txt");
										Path path2 = Path.of("d:\\readme-new.txt");
										Files.move(path1, path2);
										Перемещает и переименовывает файл
boolean isDirectory(Path path)		Проверяет, что путь — это директория, а не файл
boolean isRegularFile(Path path)	Проверяет, что путь — это файл, а не директория
boolean exists(Path path)		Проверяет, что объект по заданному пути существует
long size(Path path)			Возвращает размер файла
byte[] readAllBytes(Path path)		Возвращает все содержимое файла в виде массива байт
String readString(Path path)		Возвращает все содержимое файла в виде строки
List<String> readAllLines(Path path)	Возвращает все содержимое файла в виде списка строк
										Path path = Path.of("c:\\readme.txt");
										List<String> list = Files.readAllLines(path);

										for (String str : list)
										   System.out.println(str);
Path write(Path path, byte[])		Записывает в файл массив байт
Path writeString(Path path, String str)	Записывает в файл строку
DirectoryStream<Path> newDirectoryStream(Path dir)	Возвращает коллекцию файлов (и поддиректорий) из заданной директории
							возвращает специальный объект типа DirectoryStream<Path>. У него есть итератор(!), 
							и с помощью этого итератора можно получить все файлы и поддиректории заданной 
							директории. этот объект является потоком данных, и его нужно закрывать с помощью 
							метода close(), ну или использовать внутри try-with-resources.
							
							Path path = Path.of("c:\\windows");
							try (DirectoryStream<Path> files = Files.newDirectoryStream(path)) {
							   for (Path path : files)
							      System.out.println(path);
							}

Для использования InputStream:
InputStream input = Files.newInputStream( Path.of( src ) );



--------------------------------------------------------------------------------------------------
	~~~~~~~~~~~~~~~~~~~~ КЛАСС (интерфейс) PATH (по-сути работа с папками/путями к ним) ~~~~~~~~~~~~~~~~~~~~

Методы работы с ФС через объект Path при ошибках ввода-вывода бросают исключения; методы работы с File при ошибках возвращают false.
Path допускает работу с файлами на виртуальных файловых системах, а File нет.
File — это старый способ доступа к файловой системе, Path — это новый рекомендуемый способ.
File — это класс, Path — это интерфейс.

В ранних версиях Java для работы с файлами использовались классы типа File и FileInputStream. Но теперь класс File считается устаревшим, 
и использовать его не рекомендуется. Path — это класс, который пришел на смену File. Работа с ним безопаснее и эффективнее.

Технически Path — это не класс, а интерфейс. Так сделано для того, чтобы можно было под каждую операционную (и файловую) 
систему писать свой класс-наследник Path. У Windows свои стандарты написания пути файлов, у Linux — свои. А ведь в мире еще много 
операционных систем, и у каждой — свои стандарты. Поэтому везде в методах для работы с файлами указан интерфейс Path, а реально работа 
идет с его классами-наследниками: WindowsPath, UnixPath, ...

Чтобы создать объект Path (на самом деле это будет объект класса-наследника — WindowsPath), нужно воспользоваться командой вида:

Path file = Path.of("c:\\projects\\note.txt");		Путь к файлу
Path directory = Path.of("c:\\projects\\");		Путь к директории

Файл (или директория) не обязаны существовать, чтобы мог существовать валидный объект типа Path. Может вы только хотите создать файл.

Методы интерфейса Path:
Path getParent()			Возвращает родительскую директорию
					String str = "c:\\windows\\projects\\note.txt";
					Path path = Path.of(str).getParent();			//"c:\\windows\\projects\\"
					String str = "c:\\windows\\projects\\";
					Path path = Path.of(str).getParent();			// "c:\\windows\\"
					String str = "c:\\";
					Path path = Path.of(str).getParent();			// null

Path getFileName()			возвращает одно имя файла (без директории) или директории — то, что идет после последнего 
					разделителя:
					String str = "c:\\windows\\projects\\note.txt";
					Path path = Path.of(str).getFileName();			// "note.txt"
					String str = "c:\\windows\\projects\\";
					Path path = Path.of(str).getFileName();			// "projects"
					String str = "c:\\";
					Path path = Path.of(str).getFileName();			// null

Path getRoot()				Возвращает корневую директорию из пути
					String str = "c:\\windows\\projects\\";
					Path path = Path.of(str).getRoot();			// "c:\\"

boolean isAbsolute()			Проверяет, что текущий путь — абсолютный
Пути бывают двух типов: абсолютные и относительные. Абсолютный путь начинается с корневой директории. Для Windows это может быть папка 
c:\, для Linux — директория /

Относительный путь считается относительно какой-то директории. Т.е. это как бы конец пути, но только без начала. Относительный путь можно 
превратить в абсолютный и наоборот
. - текущая директория.
.. - директория назад. 
					String str = "c:\\windows\\projects\\note.txt";
					boolean abs = Path.of(str).isAbsolute();		// true
					String str = "src\\com\\javarush\\Main.java";
					boolean abs = Path.of(str).isAbsolute();		// false

Path toAbsolutePath()			Преобразует путь в абсолютный
					String str = "src\\com\\javarush\\Main.java";
					Path path = Path.of(str).toAbsolutePath();	     //  "d:\\work\\src\\com\\javarush\\Main.java"

Path normalize()			Убирает шаблоны в имени директории.
В пути вместо имени директории можно писать «..», и это будет означать вернуться на одну директорию назад. 
Нормализация устраняет эти вещи. Примеры:

					String str = "c:\\windows\\..\\projects\\note.txt";
					Path path = Path.of(str).normalize();			// "c:\\projects\\note.txt"
					String str = "src\\com\\javarush\\..\\Main.java";
					Path path = Path.of(str).normalize();			// "src\\com\\Main.java"

Path resolve(Path other)		Строит новый абсолютный путь из абсолютного и относительного.
					System.out.println(targetDirectory.resolve(path1.getFileName()));
					Что бы когда копируем (например), получить "<директория куда копируем> + <имя файла, кот копируем>"

Path relativize(Path other)		Получает относительный путь из двух абсолютных путей.
Метод relativize() позволяет вычислить «разницу путей»: один путь относительно другого (короткий путь относительно длинного).

					Path path1 = Path.of("c:\\windows\\projects\\note.txt");
					Path path2 = Path.of("c:\\windows\\");
					Path result = path2.relativize(path1);			// "projects\\note.txt"
					Path path1 = Path.of("c:\\windows\\projects\\note.txt");
					Path path2 = Path.of("c:\\windows\\");
					Path result = path1.relativize(path2);			// "..\\.."
					Path path1 = Path.of("c:\\aaa\\bbb\\1.txt");
					Path path2 = Path.of("d:\\zzz\\y.jpg");
					Path result = path1.relativize(path2);		// Ошибка IllegalArgumentException:
											два пути имеют разный "корень" (разные диски)

boolean startsWith(Path other)		Проверяет, что текущий путь начинается с пути
boolean endsWith(Path other)		Проверяет, что текущий путь заканчивается на путь
int getNameCount()			Дробит путь на части с помощью разделителя /. Возвращает количество частей.
Path getName(int index)			Дробит путь на части с помощью разделителя /. Возвращает часть по ее номеру.
Path subpath(int beginIndex, int endIndex) Дробит путь на части с помощью разделителя /. Возвращает часть пути, заданную интервалом.
File toFile()				Преобразует объект Path в устаревший объект File
URI toUri()				Преобразует объект Path в объект типа URI



--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~ ПОТОКИ INPUTSTREAM & OUTPUTSTREAM ~~~~~~~~~~~~~~~~~~~~

https://metanit.com/java/tutorial/6.10.php

System.in - тип InputStream
System.out - тип PrintStream (println, print, printf), наследник OutputStream, имеет его методы
Позволяет передавать в поток форматированные данные. Передаем в него поток OutputStream или файл или путь к файлу.

Начиная с Java 5 классы FileInputStream и FileOutputStream стали считаться устаревшими. Одним из их минусов было то, что при создании 
объекта этих классов сразу происходит создание файлов на диске. И потенциально выбрасываются все ошибки, связанные с созданием файлов.

Важный момент:
Если вы соединили несколько потоков в цепочку, метод close() достаточно вызвать только у одного из них: он вызовет его у своего 
источника данных и т.д., пока не дойдут до финального потока с данными

InputStream		OutputStream			Reader			Writer

FileInputStream		FileOutputStream		FileReader		FileWriter
BufferedInputStream	BufferedOutputStream		BufferedReader		BufferedWriter
							(может читать построчно)

ByteArrayInputStream	ByteArrayOutputStream		CharArrayReader		CharArrayWriter
(пр массив байт на вх)	(сохраняет во вн массив байт)

FilterInputStream	FilterOutputStream		FilterReader		FilterWriter
DataInputStream		DataOutputStream	
ObjectInputStream	ObjectOutputStream		InputStreamReader (принимает 2b FileInputStream, переводит в char, принимает Charset)
			PrintStream (форматированный вывод, переменная out явл объектом этого класса)
										OutputStreamWriter

Класс PrintStream - это именно тот класс, который используется для вывода на консоль. Когда мы выводим на консоль некоторую информацию 
с помощью вызова System.out.println(), то тем самым мы задействует PrintStream, так как переменная out в классе System как раз и 
представляет объект класса PrintStream, а метод println() - это метод класса PrintStream.
Но PrintStream полезен не только для вывода на консоль. Мы можем использовать данный класс для записи информации в поток вывода.

Наш знаменитый System.in — это ничто иное как статическая переменная in класса System. Тип ее — InputStream, а имя — in.
Применяют InputStreamReader.




Короче, ImputStream и Reader - два разных класса, никто никого не наследует. Просто импутстрим - байты, ридер - символы.

			Байты (byte)	Символы (char)
Чтение данных		InputStream	Reader
Запись данных		OutputStream	Writer

--------------------------------------------------------------------

Методы класса InputStream и всех его классов-наследников:

Методы					Описание
int read()				Читает один байт из потока. Когда в потоке не останется доступных для чтения байтов, этот метод 
					возвратит число -1
int read(byte[] buffer)			Читает массив байт из потока/ Метод возвращает число — количество реально прочитанных байт.
					Когда количество считанных байт равно 0 - возвращает -1.
					while ((count = fileInputStream.read(buff)) != -1) 
                				fileOutputStream.write(buff, 0, count);

byte[] readAllBytes()			Читает все байты из потока. Просто считывает все данные из InputStream, пока они не закончатся, 
					и возвращает их в виде единого массива байт. Очень удобен для чтения небольших файлов. 
					Большие файлы могут физически не поместиться в память, и метод кинет исключение.
long skip(long n)			Пропускает n байт в потоке (читает и выкидывает). позволяет пропустить n первых байт из объекта 
					InputStream. Поскольку данные читаются строго последовательно, этот метод просто вычитывает n 
					первых байт из потока и выбрасывает их.
int available()				Проверяет, сколько байт еще осталось в потоке
void close()				Закрывает поток


byte[] buffer = text.getBytes();	перевести строку в массив байт типа: "Hello new world!"
					[72, 101, 108, 108, 111, 32, 110, 101, 119, 32, 119, 111, 114, 108, 100, 33]

-------------------------------------------------

Методы класса OutputStream и всех его классов-наследников:

void write(int b)			Записывает один байт (не int) в поток.
void write(byte[] buffer)		Записывает массив байт в поток
void write(byte[] buffer, off, len)	Записывает часть массива байт в поток
void flush()				Записывает в поток все данные, которые хранятся в буфере
void close()				Закрывает поток	


---------------------------

Класс PrintStream. 
унаследован от класса FilterOutputStream, а тот унаследован от OutputStream. Поэтому класс PrintStream имеет все методы 
классов-родителей и плюс свои. Вот самые интересные из них:

Методы			Описание
void print(obj)		Преобразует переданный объект в строку и выводит в целевой поток.
void println(obj)	Преобразует переданный объект в строку и выводит в целевой поток. Добавляет в конце символ переноса строки
void println()		Выводит в целевой поток символ переноса строки
PrintStream format(String format, args...)	Конструирует и выводит строку на основе строки шаблона и переданных аргументов, 
						по аналогии с методом String.format()


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~ ПОТОКИ READER & WRITER ~~~~~~~~~~~~~~~~~~~~

Наследники: FileReader (читает данные из файла), InputStreamReader (читает данные из потока InputStream). Класс Reader.
Чтобы создать объект типа InputStreamReader, в него нужно передать объект типа InputStream, или его класса наследника. Пример:

String src = "c:\\projects\\log.txt";
FileInputStream input = new FileInputStream(src);
InputStreamReader reader = new InputStreamReader(input);

Основное отличие классов InputStreamReader и, например, FileReader в том, откуда они читают данные. FileReader читает данные из файла 
(поэтому он и называется FileReader), а InputStreamReader читает данные из потока InputStream.

Когда вы читаете символ из объекта FileReader с помощью метода read(), он в свою очередь читает из файла на диске два байта и 
возвращает их вам как char.

Когда вы читаете символ из объекта InputStreamReader с помощью метода read(), он в свою очередь читает два байта из переданного в него 
объекта FileInputStream, который в свою очередь читает данные из файла. Получается такая цепочка вызовов методов read().

---------------------------

BufferedReader. Это «промежуточный поток», который читает данные из другого потока (наследника Reader).

В ОТЛИЧИЕ ОТ InputStreamReader'a МОЖЕТ СЧИТАТЬ СТРОКУ.

Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный буфер в памяти, 
с помощью которого повышается производительность при чтении и записи потоков.

Когда программа читает из объекта BufferedReader один символ, он читает из своего потока-источника сразу большой массив символов. 
И сохраняет их у себя внутри.

String src = "c:\\projects\\log.txt";

try(FileReader in = new FileReader(src);
BufferedReader reader = new BufferedReader(in))
{
   while (reader.ready())					// Пока данные есть в потоке
   {
      String line = reader.readLine();
      System.out.println(line);
   }
}

Еще у класса BufferedReader есть очень полезный метод — String readLine(), который позволяет читать данные из потока-источника сразу 
строками.


Соединим оба класса BufferedReader и BufferedWriter для считывания с консоли в файл. Для этого определим следующий код программы:

public static void main(String[] args) {
         
        try(BufferedReader br = new BufferedReader (new InputStreamReader(System.in)); 
                BufferedWriter bw = new BufferedWriter(new FileWriter("notes5.txt")))
        {
           // чтение построчно
            String text;
            while(!(text=br.readLine()).equals("ESC")){
                  
                bw.write(text + "\n");
                bw.flush();
            }
        }
        catch(IOException ex){
              
            System.out.println(ex.getMessage());
        } 
    }   
---------------------------


Класс Reader — это полный аналог класса InputStream, с одним только отличием: он работает с символами — char, а не с байтами. 
Класс Reader, так же, как и класс InputStream самостоятельно нигде не используется: он является классом-родителем для сотен 
классов-наследников и задает для них всех общие методы.


Методы READER:
--------------------------------

Абстрактный класс Reader предоставляет функционал для чтения текстовой информации. Рассмотрим его основные методы:

absract void close(): закрывает поток ввода

int read(): возвращает целочисленное представление следующего символа в потоке. Если таких символов нет, и достигнут конец файла, то возвращается число -1

int read(char[] buffer): считывает в массив buffer из потока символы, количество которых равно длине массива buffer. Возвращает количество успешно считанных символов. При достижении конца файла возвращает -1

int read(CharBuffer buffer): считывает в объект CharBuffer из потока символы. Возвращает количество успешно считанных символов. При достижении конца файла возвращает -1

absract int read(char[] buffer, int offset, int count): считывает в массив buffer, начиная со смещения offset, из потока символы, количество которых равно count

long skip(long count): пропускает количество символов, равное count. Возвращает число успешно пропущенных символов



Методы WRITER:
--------------------------------

Класс Writer определяет функционал для всех символьных потоков вывода. Его основные методы:

Writer append(char c): добавляет в конец выходного потока символ c. Возвращает объект Writer

Writer append(CharSequence chars): добавляет в конец выходного потока набор символов chars. Возвращает объект Writer

abstract void close(): закрывает поток

abstract void flush(): записывает в поток все данные, которые хранятся в буфере

void write(int c): записывает в поток один символ, который имеет целочисленное представление

void write(char[] buffer): записывает в поток массив символов

absract void write(char[] buffer, int off, int len) : записывает в поток только несколько символов из массива buffer. Причем количество символов равно len, а отбор символов из массива начинается с индекса off

void write(String str): записывает в поток строку

void write(String str, int off, int len): записывает в поток из строки некоторое количество символов, которое равно len, причем отбор символов из строки начинается с индекса off

Функционал, описанный классами Reader и Writer, наследуется непосредственно классами символьных потоков, в частности классами 
FileReader и FileWriter соответственно, предназначенными для работы с текстовыми файлами.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ STACK TRACE ~~~~~~~~~~~~~~~~~~~~

Метод (последний) говорит: я был вызван в классе таком-то, меня вызвал метод такой-то, в такой-то строке, а его вызвал 
метод такой-то, в такой-то строке. КАСАЕТСЯ ИМЕННО МЕТОДОВ.

Список, состоящий из текущего метода, метода, который его вызвал, его вызвавшего метода и т.д., называется stack trace. 
Получить его можно с помощью команды:

StackTraceElement[] methods = Thread.currentThread().getStackTrace();

Можно записать ее и в две строки:
Thread current = Thread.currentThread();
StackTraceElement[] methods = current.getStackTrace();

А можно вот так:
StackTraceElement[] methods = new Throwable().getStackTrace(); // либо Throwable либо Exeption
StackTraceElement[] methods = new Exception().getStackTrace();



Метод				Описание
String getClassName()		Возвращает имя класса
String getMethodName()		Возвращает имя метода
String getFileName()		Возвращает имя файла (в одном файле может быть много классов)
int getLineNumber()		Возвращает номер строки в файле, в которой был вызов метода
String getModuleName()		Возвращает имя модуля (может быть null)
String getModuleVersion()	Возвращает версию модуля (может быть null)


public static void main(String[] args) {
        test();
    }

    public static void test() {
        Thread current = Thread.currentThread();
        StackTraceElement[] methods = current.getStackTrace();

        for(StackTraceElement info: methods)
        {
            System.out.println(info.getClassName());
            System.out.println(info.getMethodName());

            System.out.println(info.getFileName());
            System.out.println(info.getLineNumber());

            System.out.println(info.getModuleName());
            System.out.println(info.getModuleVersion());
            System.out.println();
        }
    }


Еще одно интересное применение стека — обработка исключений.
Когда в программе происходит ошибка и создается исключение, в него записывается текущий stack trace: массив, состоящий из списка методов 
начиная с метода main и заканчивая методом, где произошла ошибка. Там даже есть строка, в которой было создано исключение!

Этот stack trace ошибки хранится внутри исключения и может быть легко извлечен из нее с помощью метода: StackTraceElement[] getStackTrace()

Пример:

Код				Примечание
try
{
   				// тут может возникнуть исключение
}
catch(Exception e)		// Захватываем исключение
{
   StackTraceElement[] methods = e.getStackTrace()		// Получаем из него стек-трейс в момент возникновения ошибки.
}

Говоря простыми словами у объекта исключаения (е) есть метод получения стек-трейса.
Это метод класса Throwable, а значит, все его классы-наследники (т.е. вообще все исключения), имеют метод getStackTrace().

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ИСКЛЮЧЕНИЯ try-catch ~~~~~~~~~~~~~~~~~~~~

Как обработать "внутреннее" исключение, если в блоке catch при обработке исключения случилось другое исключение??
Если возникло два однотипных исключения, как сохранить первое?

Список всех исключений: https://proglang.su/java/exceptions-built-in-exceptions

По сути исключения делятся на два типа: условно аварийные (мы о них не знали, типа как деление на 0) - они не требуют прописывать
trows в сигнатуре и мы можем их подхватить в текущем или вышестоящем методе И контролируемые - коротые мы выкидываем сами через trow, для
последующей отработки в вышестоящих методах.

Try может работать без catch, но тогда нужен finally.

try-with-resources (работает, начиная с Java 7)
-------------------------------
Это еще одна разновидность оператора try. После ключевого слова try нужно добавить круглые скобки, а внутри них — создать объекты с 
внешними ресурсами. Для объекта, указанного в круглых скобках, компилятор сам добавит секцию finally и вызов метода close().


FileOutputStream output = null;				try(FileOutputStream output = new FileOutputStream(path))
							{
try								output.write(1);
{
   output = new FileOutputStream(path);			}
   output.write(1);
}
finally
{
   if (output != null)
   output.close();
}

Можно инициализировать множество объектов в скобках, необязательно один.
-------------------------------------------------------------------------------

Много полезной инфы: https://javarush.com/groups/posts/4103-kofe-breyk-220-kak-ispravljatjh-iskljuchenija-v-java--podrobnoe-rukovodstvo

try
{
   код, где может возникнуть ошибка
}
catch(ТипИсключения имя)
{
   код обработки исключения
}

Исключение, возникшее в блоке try, может быть захвачено только одним блоком catch. Не может быть ситуации, что при обработке исключения 
выполнился код из нескольких блоков catch.

Вы всегда можете снова вбросить Java-машине исключение, которое только что перехватили. Для этого нужно использовать оператор throw:
throw исключение;

Повторно выброшенное исключение не может быть захвачено другими блоками catch этого же try-блока. ЕСЛИ ТОЛЬКО ЭТО НЕ РУКУРСИЯ.


Код в блоке finally выполнится в любом случае независимо от того, было исключение или не было. Даже если исключение возникло, и оно не 
было перехвачено, блок finally все равно выполнится.
Кстати, если вы не хотите перехватывать исключение, а блок finally вам нужен, используйте сокращенную запись 
блока try-catch-finally — try-finally. Выглядит это примерно так:

try
{
   код, где может возникнуть ошибка
}
finally
{
   код, который нужно выполнить в любом случае
}

----------------------------------------

Создание собственного исключения:
try
{
   throw new RuntimeException();
}
catch(Exception except)
{
   System.out.println("Перехватили исключение");
   throw except;
}


Если метод выбрасывает checked-исключение, он должен содержать тип этого исключения в своем заголовке (сигнатуре метода). 
Чтобы все методы, которые вызывают данный метод, знали о том, что в нем может возникнуть такое «важное исключение».
ТОЕСТЬ, если мы не указываем его в сигнаруте, код скомпилится, но вышестоящий метод, вызвавший викунувший исключение
не бужет знать, что его нужно "обернуть". Если иксепшн чект, код не скомпилится, пока не обернем.

Чект исключения мы добавляем в сигнатуру вызываемого метода и они обязательны для отработки, т.к. можем их контролировать, анчект - нет.

------------------------------------------------

Если необходимо даунгрейдить эксепшн:
try
{
   // код где мы запаковали checked исключение
   // в RuntimeException
}
catch(RuntimeException e)
{
   Throwable cause = e.getCause();
   if (cause instanceof Exception)
   {
      Exception exp = (Exception) cause;
      // тут код по обработке Exception
   }
}

--------------------------------------------

Начиная с 7-й версии, в язык Java добавили возможность указать несколько типов исключений в одном блоке catch. 
Выглядит это примерно так:

try
{
   код, где может возникнуть ошибка
}
catch(ТипИсключения1 | ТипИсключения2 | ТипИсключения3 имя)
{
   код обработки исключений
}
Блоков catch может быть сколько угодно. Однако в одном блоке catch нельзя указать исключения, которые наследуются друг от друга. 
Т.е. нельзя написать catch (Exception | RuntimeException e), т.к. класс RuntimeException унаследован от Exception.

----------------------------------------------

RuntimeExeption (непроверяемые):

ArithmeticException: исключение, возникающее при делении на ноль

IndexOutOfBoundException: индекс вне границ массива

IllegalArgumentException: использование неверного аргумента при вызове метода

NullPointerException: использование пустой ссылки

NumberFormatException: ошибка преобразования строки в число

IllegalStateException - это тип RuntimeException, который возникает, когда объект находится в неподходящем состоянии для выполняемой 
операции. Это может произойти, если метод вызывается для объекта, который не находится в ожидаемом состоянии. Например, если мы 
создадим объект подключения к базе данных, а затем закроем его.

ClassCastException - знакомятся новички когда пытаются привести объект к классу, экземпляром которого он не является.



Exeption (проверяемые):

Все остальные классы, образованные от класса Exception, называются проверяемыми исключениями (checked exceptions).
Некоторые из классов проверяемых исключений:

CloneNotSupportedException: класс, для объекта которого вызывается клонирование, не реализует интерфейс Cloneable

InterruptedException: поток прерван другим потоком

ClassNotFoundException: невозможно найти класс

IOException — ошибка при вводе-выводе данных (Input-Output). Например при чтении текста из файла.



throws не применим к классам, только методы


Методы:
getMessage() - вывести сообщение, указанное в скобках исключения
getCause() - Метод getCause() возвращает исключение-причину, то есть исключение, которое было обернуто текущим исключением. 
		Он возвращает только непосредственную причину текущего исключения, а не всю цепочку исключений. 
		То есть он выдаст не корневую ошибку, а ошибку предыдущего уровня
getStackTrace() возвращает массив, содержащий трассировку стека исключения

printStackTrace() 	печать стек трейса, что бы не пришлось в Arrays.toString заворачивать (вызывется у объекта исключения е.)


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ GENERICS ~~~~~~~~~~~~~~~~~~~~

Стирание типов - когда комиплятор в раельности создает не типизированный объект, а принимает Object и возвращает Object приведенный к 
нашему типизированному типу. То есть, это реально выполнение программы компилятором без дженериков, а посредством принятия Object и 
кастования его до переданного в дженерик типа. Дженерики работают только на этапе компиляции. Далее, в байт-коде, будут Object и его cast's.


Bridge Method - это созданный компилятором метод (@real override), который принимает Object и далее вызывает наш метод (@override)
compareTo ((Person) obj), для сохранения сигнатуры переопределенного метода:

public interface Comparable {
    int compareTo (Object o);
}

public class Person implements Comparable<Person> {
   @Override
   public int compareTo (Person o)
   return 0;
}

@RealOverride
public int compareTo (Object o) {
    return compareTo ((Person) o);
}

То есть бридж-метод - это метод для реального переопределения метода (как вариант), вызывая потом наш "типа" переопределенный метод.

В Java нельзя параметризировать классы:
- имеющие в предках Throwable (т.к. типы сотрутся, а exception будут равны):
catch (SomeException<String> ex) {
}
catch (SomeException<Integer> ex) {
}
- анонимные классы
- Enum's

class Fruit;

class Citrus extends Fruit;

class Orange extends Citrus;

Наследник содержит все поля и методы родителя, и может быть использован.
То есть содержит всю информацию рожителя и может быть использован, но только как родитель (приводится к типу родитель).

Fruit = new Orange;

Дженерики инвариантны!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
Код List<Number> numbers = new ArrayList<Integer>(); - не скомпилируется!!!!!!!!!!
А массив Number[] numbers = new Integer[10] - скомпилируется. Массивы - ковариантны.
Почему дженерики таковы?
Вот пример, когда в вышеуказанный массив мы можем положить double:\
numbers[0] = 9.7d;   - ведь он number! Соотв. будет ArrayStoreEsxception в Runtime.

Инвариантность - это когда списку типа Integer (например) мы можем присвоить только список такого же типа. Не наследника, не родителя.
ArrayList<Orange> orange = new ArrayList<>();
Это связано с тем, что иначе, если бы мы могли сделать:
ArrayList<Citrus> citrus = new ArrayList;
citrus = orange; 
Тогда цитрусЛист ссылался бы на объекты оранжлист и мог бы добавить объеты цитруса в оранж.

Ковариантность (вернхяя граница подстановки - это возможность работы с типами-наследниками. Когда мы в метод можем передать тип 
верхней границы подстановки:
int weightCount (ArrayList<? extends Citrus> obj) {}
Мы можем читать цитруса или любого его предка, т.к. цитрус хранит в себе данные о нем.
Писать в список при ковариантности мы не можем, т.к. может быть передан список Oranges (например), а мы попытаемся добавить Citrus, 
который не может быть приведен к Оранжу.

Контрвариантность (нижняя граница подстановки) - это когда мы можем передать в метод и работать с указанным типом + его предками. 
Читать ничего нельзя, но можно добавлять элементы начиная от оранжа и вниз (БигРаундОранж), т.к. для всех типов выше есть инфо из наследников.

Extends (ковариантность) - используется в классах, что бы из них читать, т.к. наследники обладают всей полнотой инфо.
Super (контрвариантность) - используются, что бы писать (но только этот класс либо предков), т.к. в этот же класс писать его же - ок, а в вышестоящие
его либо наследников - тоже ок.

PECS - Producer Extends Consumer Super. Поставщик - читает, пользователь - пишет.

Сюда же ложится принцип подстановки Барбары Лисков - когда S extends T, можно в программе менять T на S не опасаясь последствий. Но, это не работает
с ArrayList в том плане, что они инвариативны.

исключением является возможность записать null для extends и прочитать Object для super

---------------------------- Разбор статьи https://habr.com/ru/companies/sberbank/articles/416413/:

Массивы в Java ковариантны. Тип S[] является подтипом T[], если S — подтип T. Пример присваивания:
String[] strings = new String[] {"a", "b", "c"};
Object[] arr = strings;


Всегда ли Generics инварианты? Нет. Приведу примеры:
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;

Это ковариантность. List<Integer> — подтип List<? extends Number>

List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;

Это контравариантность. List<Number> является подтипом List<? super Integer>. 





Ограничения:
1. Параметризированные типы могут работать только со ссылочными типами
2. Нельзя создавать массивы объектов обобщенного типа. Для этого нужно создать массив Object[] obj = new Object[10];
	а при возвращенни нужно return (T) obj;
3. Нельзя создавать объект обобщенного типа ч/new - T obj = new T();
	т.к. неизветно что это за объект и есть ли у него конструктор без параметров.

? (любой wild card) нужен, когда мы хотим ввести какой-то тип, не указанный в сигнатуре класса в кач-ве дополнительного 
(второго, ч/зпт. и д.т.). Получется, что тип, не указанный в сигнаруте класса может быть введен либо ч/? либо через сигнатуру
метода либо ч/конструктор, но мы не сможем использовать этот тип выше в полях.

<? super Number> действительно подразумевает "любой тип, являющийся супер-классом для Number". Плюс сам Number.

В класс, реализующий параметризированный тип можно передать объект этого типа, либо объект-наследник этого типа, без указания extends.
Basket<Fruit> fruitBasket = new Basket<>();
        fruitBasket.add(new Apple());
        fruitBasket.add(new Orange());

class Basket<F extends Fruit> {
    ArrayList<F> fruits = new ArrayList<>();

Единственное что, мы не сможем использовать методы класса T, т.к. - это не конкретизированная болванка, а просто болванка.
То есть в баскет типа F (Basket<Fruit> fruitBasket = new Basket<>();) мы можем положить его наследников. Но пользоваться методами не можем.
А вот в баскет F exends Fruit можем пользоваться методами.

--------------------------------------------------------------------

Обобщения могут применяться к классам:
public class Program{
      
    public static void main(String[] args) {
          
        Account<String> acc1 = new Account<String>("2345", 5000);
        String acc1Id = acc1.getId();
        System.out.println(acc1Id);
         
        Account<Integer> acc2 = new Account<Integer>(2345, 5000);
        Integer acc2Id = acc2.getId();
        System.out.println(acc2Id);
    }
}
class Account<T>{
     
    private T id;
    private int sum;
     
    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }
     
    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}

--------------------------------------------------------------

Интерфейсам:
public class Program{
      
    public static void main(String[] args) {
          
        Account<String> acc1 = new Account<String>("1235rwr", 5000);
        Account<String> acc2 = new Account<String>("2373", 4300);
        System.out.println(acc1.getId());
        System.out.println(acc2.getId());
    }
}
interface Accountable<T>{
    T getId();
    int getSum();
    void setSum(int sum);
}
class Account<T> implements Accountable<T>{
     
    private T id;
    private int sum;
     
    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }
     
    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}

--------------------------------------------------------------

Методам:
public class Program{
      
    public static void main(String[] args) {
          
        Printer printer = new Printer();
        String[] people = {"Tom", "Alice", "Sam", "Kate", "Bob", "Helen"};
        Integer[] numbers = {23, 4, 5, 2, 13, 456, 4};
        printer.<String>print(people);
        printer.<Integer>print(numbers);
    }
}
 
class Printer{
     
    public <T> void print(T[] items){
        for(T item: items){
            System.out.println(item);
        }
    }
}

--------------------------------------------------------------

Конструкторам:
public class Program{
      
    public static void main(String[] args) {
          
        Account acc1 = new Account("cid2373", 5000);
        Account acc2 = new Account(53757, 4000);
        System.out.println(acc1.getId());
        System.out.println(acc2.getId());
    }
}
 
class Account{
     
    private String id;
    private int sum;
     
    <T>Account(T id, int sum){
        this.id = id.toString();
        this.sum = sum;
    }
     
    public String getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}

--------------------------------------------------------------

А так же можно создать сразу несколько универсальных параметров:
public class Program{
      
    public static void main(String[] args) {
          
        Account<String, Double> acc1 = new Account<String, Double>("354", 5000.87);
        String id = acc1.getId();
        Double sum = acc1.getSum();
        System.out.printf("Id: %s  Sum: %f \n", id, sum);
    }
}
class Account<T, S>{
     
    private T id;
    private S sum;
     
    Account(T id, S sum){
        this.id = id;
        this.sum = sum;
    }
     
    public T getId() { return id; }
    public S getSum() { return sum; }
    public void setSum(S sum) { this.sum = sum; }
}


Идея в том, что если мы пишем Class Account <T>, то внутри класса он (класс) не знает, что за тип <T> к нему пришел и не может вызывать
его методы. Обрабатываем "снаружи", там, где этот тип известен (вызывающий метод класса).
Если мы делаем ограничение Class Account <T extends String>, тогда он будет знать что за класс к кему пришел и сможет
вызывать его методы. То есть, для раннего связывания мы должны конкретно указать тип. Раннее связывание - это то, что явно видно на этапе
компилятора. Вызовы методов поступивших объектов, например.

Множественные ограничения
Также можно установить сразу несколько ограничений. Например, пусть класс Transaction может работать только с объектами, которые 
одновременно реализуют интерфейс Accountable и являются наследниками класса Person:


class Person{}
interface Accountable{}
 
class Transaction<T extends Person & Accountable>{}


По сути дженерик - это то, к чему будет приводиться наш тип? - Нет, это тип-болванка (может быть с ограничениями), который будет задан
внешним типом (снаружи).

Под дженериками в Java подразумевают возможность добавлять к типам типы-параметры. Таким образом получаются сложные составные типы. 
Такой составной тип в общем случае выглядит так:

ОсновнойТип<ТипПараметр>

Принцип работы дженерика. Компилятор просто заменяет тип с параметром на него же, только без параметра. А при взаимодействии с его 
методами добавляет операцию приведения типа к типу-параметру:

Код										Что сделает компилятор
ArrayList<Integer> list = new ArrayList<Integer>();				ArrayList list = new ArrayList();
list.add(1);									list.add( (Integer) 1 );
int x = list.get(0);								int x = (Integer) list.get(0);
list.set(0, 10);								list.set(0, (Integer) 10);
--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ITERATOR ~~~~~~~~~~~~~~~~~~~~

Класс Iterator отвечает за безопасный проход по списку элементов. 

Он достаточно прост, поскольку имеет всего 3 метода:
hasNext() — возвращает true или false в зависимости от того, есть ли в списке следующий элемент, или мы уже дошли до последнего.
next() — возвращает следующий элемент списка
remove() — удаляет элемент из списка

ArrayList<Cat> cats = new ArrayList<>();
   Cat thomas = new Cat("Томас");
   Cat behemoth = new Cat("Бегемот");
   Cat philipp = new Cat("Филипп Маркович");
   Cat pushok = new Cat("Пушок");

Iterator<Cat> catIterator = cats.iterator();//создаем итератор
while(catIterator.hasNext()) {			//до тех пор, пока в списке есть элементы

   Cat nextCat = catIterator.next();		//получаем следующий элемент		// Вставка через итератор it.add(value)
   if (nextCat.name.equals("Филипп Маркович")) {
       catIterator.remove();			//удаляем кота с нужным именем
   }
}

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ COLLECTION (интерфейс) ~~~~~~~~~~~~~~~~~~~~

Методы Collection
 

add(item) — добавляет элемент item в коллекцию;

addAll(collection) — добавляет в коллекцию другую коллекцию, ту, что указана в скобках;

contains(item) — возвращает true или false в зависимости от того, есть ли в коллекции элемент item;

containsAll(collection) — работает так же, как предыдущий, но проверяет наличие в коллекции не элемента, а другой коллекции;

remove(item) — удаляет из коллекции указанный элемент;

removeAll(collection) — удаляет те элементы, которые представлены в другой коллекции. 

retainAll(collection) — оставляет в коллекции только те элементы, которые представлены в другой коллекции. 

clear() — очищает коллекцию, то есть удаляет из нее все элементы;

size() — выдает количество элементов в коллекции в формате целого числа;

isEmpty() — возвращает true или false в зависимости от того, пуста ли коллекция;

toArray() — превращает коллекцию в массив.


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ DEQUEUE (интерфейс) ~~~~~~~~~~~~~~~~~~~~


Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо 
как стек, действующий по принципу LIFO (последний вошел — первый вышел).

Интерфейс Deque определяет следующие методы:

void addFirst(E obj): добавляет элемент в начало очереди

void addLast(E obj): добавляет элемент obj в конец очереди

E getFirst(): возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение NoSuchElementException

E getLast(): возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение NoSuchElementException

boolean offerFirst(E obj): добавляет элемент obj в самое начало очереди. Если элемент удачно добавлен, возвращает true, иначе — false

boolean offerLast(E obj): добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе — false

E peekFirst(): возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null

E peekLast(): возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение null

E pollFirst(): возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null

E pollLast(): возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение null

E pop(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException

void push(E element): добавляет элемент в самое начало очереди

E removeFirst(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException

E removeLast(): возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение NoSuchElementException

boolean removeFirstOccurrence(Object obj): удаляет первый встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false.

boolean removeLastOccurrence(Object obj): удаляет последний встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false.

 

Таким образом, наличие методов pop и push позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет 
создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ QUEUE (интерфейс) ~~~~~~~~~~~~~~~~~~~~

Поскольку Queue является интерфейсом, вам необходимо создать конкретную реализацию, чтобы использовать его. Вы можете выбрать одну из следующих в API коллекций:

java.util.LinkedList – довольно стандартная реализация очереди;
java.util.PriorityQueue хранит свои элементы внутри в соответствии с их естественным порядком (если они реализуют Comparable) или в соответствии с Comparator, 
переданным в PriorityQueue.


Обобщенный интерфейс Queue<E> расширяет базовый интерфейс Collection и определяет поведение класса в качестве однонаправленной очереди. 
Свою функциональность он раскрывает через следующие методы:

E element(): возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException

boolean offer(E obj): добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе — false

E peek(): возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null

E poll(): возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null

E remove(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException


Таким образом, у всех классов, которые реализуют данный интерфейс, будет метод offer для добавления в очередь, метод poll для извлечения элемента из головы очереди, 
и методы peek и element, позволяющие просто получить элемент из головы очереди.


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ LIST(интерфейс) ~~~~~~~~~~~~~~~~~~~~

Представляет собой упорядоченную коллекцию данных, похожую на массив. Это значит, что у его элементов есть порядковые номера, показывающие их расположение 
в списке, — индексы. Но, в отличие от массива, List динамический, о чем мы говорили выше, — в нем можно изменять количество элементов.

Его реализуют: ArrayList, LinkedList.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ Никто не использует LinkedList ~~~~~~~~~~~~~~~~~~~~

То же самое, что ArrayList, только не через массив, а через двусвязанный список.

Он отличается от ArrayList наличием связности: в каждом элементе есть указатели на предыдущий и следующий элемент. Методы у него такие же, как у динамического массива,
но действия с таким списком различаются сложностью выполнения и скоростью. Методы add() и remove() в связанном списке имеют фиксированную скорость выполнения, 
поэтому оптимальнее. А вот обращение к элементу по индексу быстрее в ArrayList.

LinkedList — реализует интерфейс List. Является представителем двунаправленного списка, где каждый элемент структуры содержит указатели на предыдущий и следующий 
элементы. Итератор поддерживает обход в обе стороны. Реализует методы получения, удаления и вставки в начало, середину и конец списка. Позволяет добавлять любые 
элементы в том числе и null.


Итоги

— Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
— На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n). Однако, на добавление и удаление из середины 
списка, используя ListIterator.add() и ListIterator.remove(), потребуется O(1);
— Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует соответствующие классы-оберки;
— Не синхронизирован.

Методы:


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ARRAYLIST (относится к коллекциям) ~~~~~~~~~~~~~~~~~~~~

— Быстрый доступ к элементам по индексу за время O(1);
— Доступ к элементам по значению за линейное время O(n);
— Медленный, когда вставляются и удаляются элементы из «середины» списка;
— Позволяет хранить любые значения в том числе и null;
— Не синхронизирован.


ArrayList<String> s = new ArrayList<>() {{
            add("2");
            add("3");
        }};

In round brackets we also can state the list size: ArrayList<Integer> list = new ArrayList<Integer>(2);

One particular List may store different type values:
var elements = new ArrayList<>();
        elements.add("Привет");
        elements.add(10);
        elements.add(new Integer[15]);

And we can also write it this way: 
ArrayList numbers = new ArrayList();


ArrayList<Integer> list = new ArrayList<Integer>();		Список целых чисел
ArrayList<String> list = new ArrayList<String>();		Список строк
ArrayList<Integer> numbers = new ArrayList<>(Arrays.asList(56, 45, 89, 1, 45, 13, 4, 69, 11, -89)); Массив Integer's

Коллекции, в отличие от массивов, не могут хранить примитивные типы: только типы-классы.

Методы:					Описание:

addAll(anotherList)			добавляет в нашу коллекцию другую коллекцию

indexOf(name)				возвращает индекс первого вхождения элемента в списке

lastIndexOf(Object o)			возвращается индекс последнего элемента в списке. Если элемент не найден, также возвращает -1.

void add(тип value)			Добавляет в список переданный элемент

void add(int index, тип value)		Добавляет элемент в определенное место списка. Смещает остальные элементы вправо.

тип get(int index)			Возвращает элемент, который находится под номером index

void set(int index, тип value)		Меняет значение элемента с номером index на value

тип remove(int index)			Удаляет элемент под номером index либо можно указать имя объекта. Возвращает удаленный элемент. Смещает остальные элементы 
					влево.

remove(Object o)			Метод удаляет из списка переданный элемент o. Если элемент присутствует в списке, он удаляется, 
					все элементы смещаются влево. Если элемент существует в списке и успешно удален, метод 
					возвращает true, в обратном случае — false.

boolean remove(тип value)		Удаляет элемент: нужно передать сам элемент в список. Если таких элементов несколько, будет удален первый из них.

void clear()				Очищает список — удаляет все элементы из списка.

boolean contains(тип value)		Проверяет, содержится ли в списке элемент value.

boolean isEmpty()			Проверяет, пустой список или нет. Равна ли длина списка нулю.

int size()				Возвращает размер списка — количество элементов списка.

тип[] toArray(тип[] array)		Возвращает массив, содержащий те же элементы, что и список.
					Массив нужно передать в метод.
					// String [] s = list.toArray(new String[0]);

asList()				Представить массив в виде списка
					List<String> wordsList = Arrays.asList("I", "love", "learning", "on", "JavaRush");

clone()					Возвращает объект-копию массива:
					ArrayList<String> copyOfSecondList = (ArrayList<String>) secondList.clone();
					Следует обратить внимание, что метод clone() возвращает Object, так что после его вызова 
					потребуется сделать приведение к необходимому классу.

subList(index from, imdex to)		Возвращает подсписок


ч.1 Приветсти лист к массиву строк. Получаем массив объектов, который приводим к String
String[] wordsArray = (String[]) wordsList.toArray();

ч.2 В качестве аргуметна передать в метод массив, на выходе получаем не просто массив объектов, а массив определенного типа данных.
примитивные похоже нельзя.
String[] wordsArray = wordsList.toArray(new String[0]);
Если длина массива меньше списка, будет создан массив подходящей длины.
Если равна:
String[] array = new String[wordsList.size()];
wordsList.toArray(array);		// то мы просто отправляем туда наш массив, ОН ЗАПОЛНЯЕТСЯ
Если больше - добавит null в конце.

- ensureCapacity(int)			Устанавливает емкость массива

- trimToSize() 				Обрезает емкость этого экземпляра ArrayList до его текущих размеров.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ КОНТЕЙНЕРЫ И КОЛЛЕКЦИИ ~~~~~~~~~~~~~~~~~~~~

ArrayList - по сути динамический массив, имеет номера элементов.

HashSet - множество уникальных неупорядоченных элементов (типа кучи). Реализован на основе хеш-таблицы. Когда элемент добавляется в 
HashSet, он сначала конвертируется в хэш-код — целочисленное значение, которое используется ключом для хранения элемента в хэш-таблице. 
Это позволяет быстро находить и проверять наличие элемента в коллекции. Для каждого элемента уникальных хеш. Позволяет иметь одно
null значение. Не имеет номера элементов.

HashMap - тоже на основании хеш-таблицы, но именно в паре. Т.е. допускается существ. одинаковых элементов с разными ключами. Ключи
повторяться не могут. HashMap допускает один нулевой ключ и любое количество нулевых значений. Не имеет номера элементов. Элеметы 
храянятся хаотически.

То есть, в сете у элементов стандартный хеш, который задается hashcode автоматически, а в мапе наш, поэтому элементы могут быть 
одинаковые (с разными хэшами).

Удалить элемент из коллекции можно через for (not each), itterator, list copy creation: 
ArrayList<String> list1 = new ArrayList<>(list);
        for (String s: list1) {
            if (s.equalsIgnoreCase("bug"))
                list.remove(s);
        }


А еще можно вот так  list.removeIf(s -> s.equalsIgnoreCase("bug"));

Контейнерами или коллекциями называют классы, которые позволяют хранить и обрабатывать много объектов сразу. 
Вы уже знаете две разновидности контейнеров — массивы и списки.

В Java есть несколько десятков коллекций, каждая из которых хранит элементы своим специфическим способом. Вот некоторые из них:

Тип коллекции		Класс		Описание
List			ArrayList	Список
			LinkedList	Связный список
			Vector		Вектор
			Stack		Стэк (стопка)
------------------------------------------------------
Set			HashSet		Множество
			TreeSet
			LinkedHashSet
------------------------------------------------------
Queue			PriorityQueue	Очередь
			ArrayDeque
------------------------------------------------------
Map			HashMap		Карта/Словарь
			TreeMap
			HashTable


Тут есть некоторая неоднозначность с именами. Хотя в большинстве языков программирования все эти структуры данных принято называть 
коллекциями, в Java это не так. В языке Java некоторые из этих классов реализуют интерфейс Collection, в то время как другие — нет.

Поэтому коллекции разделились на коллекции в широком смысле и коллекции в узком смысле (только те, которые реализуют интерфейс 
Collection).

Поэтому, чтобы не путаться, коллекциями называют только коллекции в узком смысле (классы должны реализовывать интерфейс Collection). 
Это все коллекции типа List, Set и Queue. Коллекции же в широком смысле принято называть контейнерами. К ним относятся классы типа 
Map и массивы.

Методы класса Collections:

Методы					Описание
addAll(colls, e1, e2, e3, ..)		Добавляет в коллекцию colls элементы e1, e2, e3,...
fill(list, obj)				Заменяет в переданном списке все элементы на obj
nCopies(n, obj)				Возвращает список, состоящий из n копий объекта obj. Список можно назвать фиктивным 
					(реального массива внутри нет), поэтому изменять его нельзя! Можно использовать только для 
					чтения.
replaceAll(list, oldVal, newVal)	Заменяет в списке list все значения oldVal на newVal
copy(dest, src)				Копирует все элементы из списка src в список dest. Коллекция dest должна иметь длину не меньше,
					чем длина коллекции src (иначе кинется исключение IndexOutOfBoundsException).
reverse(list)				Разворачивает список задом наперед
sort(list)				Сортирует список в порядке возрастания
rotate(list, n)				Циклично сдвигает элементы списка list на n элементов (like bracelet)
shuffle(list)				Случайно перемешивает элементы списка
min(colls)				Находит минимальный элемент коллекции colls
max(colls)				Находит максимальный элемент коллекции colls
frequency(colls, obj)			Определяет, сколько раз элемент obj встречается в коллекции colls
binarySearch(list, key)			Ищет элемент key в отсортированном списке, возвращает индекс. Если элемент не найден, 
					возвращает отрицательное число. 
					!!!!!!!!!! Перед вызовом метода binarySearch() список нужно отсортировать Collections.sort().
disjoint(colls1, colls2)		Возвращает true, если у коллекций нет общих элементов


--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ LIST STACK ~~~~~~~~~~~~~~~~~~~~


Стек — это структура хранения данных, в которую можно добавлять элементы и из которой можно забирать элементы. 
Причем брать элементы можно только с конца: сначала последний добавленный, потом — предпоследний, и т.д.

Само название Stack переводится с английского как «стопка» и очень похоже на стопку бумаги. Если вы положите на стопку бумаги листы 
1, 2 и 3, взять вы их сможете только в обратном порядке: сначала третий, затем второй, а только затем первый.

Методы				Описание
T push(T obj)			Добавляет элемент obj в конец списка (наверх стопки)
T pop()				Забирает элемент с верха стопки (высота стопки уменьшается)
T peek()			Возвращает элемент с верха стопки (стопка не меняется)
boolean empty()			Проверяет, не пуста ли коллекция
int search(Object obj)		Ищет объект из коллекции, возвращает его index

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ HASHMAP COLLECTION ~~~~~~~~~~~~~~~~~~~~

Map.Entry - это вложенный интерфейс "Entry" в интерфейсе "Map". Метод entrySet() возвращает множество объектов типа Entry, содержащих ключ и значение.

boolean equals(Object obj): возвращает true, если объект obj, представляющий интерфейс Map.Entry, идентичен текущему

K getKey(): возвращает ключ объекта отображения

V getValue(): возвращает значение объекта отображения

V setValue(V v): устанавливает для текущего объекта значение v

int hashCode(): возвращает хеш-код данного объекта

---------------------------------------------------------------

HashMap<String, Double> grades = new HashMap<>();
Вы можете указать свои емкость и коэффициент загрузки, используя конструкторы HashMap(capacity) и HashMap(capacity, loadFactor). 
Максимальная емкость, которую вы сможете установить, равна половине максимального значения int (1073741824).

Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. 
Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. 
Поэтому строка наиболее часто используется в качестве ключа HashMap.

Метод						Описание
void put(ТКлюч key, ТЗначение value)		Добавляет в коллекцию пару (key, value)
						Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее 
						значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
putAll()					Объединение двух мап в одну
ТЗначение get(ТКлюч key)			Возвращает значение по ключу.
boolean containsKey(ТКлюч key)			Проверяет наличие ключа в коллекции
boolean containsValue(ТЗначение value)		Проверяет наличие значения в коллекции
ТЗначение remove(ТКлюч key)			Удаляет элемент из коллекции
void clear()					Очищает коллекцию: удаляет все элементы
int size()					Возвращает количество пар элементов в коллекции
Set<ТКлюч> keySet()				Возвращает множество ключей коллекции
Collection<ТЗначение> values()			Возвращает множество элементов коллекции
Set<Map.Entry<TКлюч, TЗначение>> entrySet()	Возвращает все значения коллекции в виде множества (Set) пар (Map.Entry):

for(Map.Entry<String, Integer> (можно заменить на просто var) pair: map.entrySet())
{
   String key = pair.getKey();
   Integer value = pair.getValue();
   System.out.println(key + " --> " + value);
}
boolean equals(Object obj)			возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj

V putIfAbsent(K k, V v): 			помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет 
						элемента с подобным ключом.

getOrDefault(key, defaultValue) 		возвращает значение ключа для key, либо, если такого ключа нет, указанное значение
public static Map<String, Integer> countWords(String[] words) {
        Map<String, Integer> wordCount = new HashMap<>();
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }

computeIfAbsent():				кладет в мапу ключ / значение, при этом вычисляет значение по функции, если его раньше
(кэмпьют) - вычислять				не было (кладем в первый раз)
= to calculate					
						// если такого ключа не было, положить новый ArrayList и добавить значение
public void accept(All<T> all) {		// а елси был, то просто добавить в ArrayList
    if (all != null) {				
        mailBox.computeIfAbsent(all.getTo(), key -> new ArrayList<>()).add(all.getContent());
    }						

computeIfPresent()				Этот метод позволяет обновить значение для указанного ключа, если он присутствует в карте.
						Ну то же самое, но когда кладем ВТОРОЙ И ДАЛЕЕ разы можно установить правило обновления
						значения.

putIfAbsent()					Этот метод добавляет пару ключ-значение в карту только в том случае, если ключ 
						отсутствует в карте. Если ключ уже присутствует в карте, метод не делает ничего.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ HASHSET COLLECTION ~~~~~~~~~~~~~~~~~~~~

Для создания объекта HashSet можно воспользоваться одним из следующих конструкторов:

HashSet(): создает пустой список

HashSet(Collection<? extends E> col): создает хеш-таблицу, в которую добавляет все элементы коллекции col

HashSet(int capacity): параметр capacity указывает начальную емкость таблицы, которая по умолчанию равна 16

HashSet(int capacity, float koef): параметр koef или коэффициент заполнения, значение которого должно быть в пределах от 0.0 до 1.0, указывает, насколько должна быть заполнена емкость объектами прежде чем произойдет ее расширение. Например, коэффициент 0.75 указывает, что при заполнении емкости на 3/4 произойдет ее расширение.


Вы можете добавить любой объект в набор. Если набор не типизирован с использованием Java Generics, то вы можете даже смешивать объекты разных типов (классов) в одном 
наборе. Однако в действительности смешивание объектов разных типов в одном наборе не часто выполняется.


Поскольку Set – это интерфейс, вам нужно создать конкретную реализацию, чтобы использовать его. Вы можете выбрать:

java.util.EnumSet;
java.util.HashSet;
Jawakutilklaidaked ashset;
java.util.TreeSet;


Оказывается можно передать в HashSet лист напрямую:

String[] wordsArray = "Думаю, это будет новой фичей. Только не говорите никому, что она возникла случайно.".split(" ");
ArrayList<String> wordsList = new ArrayList<>(Arrays.asList(wordsArray));
HashSet<String> wordsHashSet = new HashSet<>(wordsList);



HashSet<Тип> имя = new HashSet<Тип>();

Метод				Описание
boolean add(Тип value)		Добавляет элемент value в коллекцию
boolean remove(Тип value)	Удаляет элемент value из коллекции. Возвращает true, если там такой элемент был
boolean contains(Тип value)	Проверяет, есть ли в коллекции элемент value
void clear()			Очищает коллекцию: удаляет все элементы
int size()			Возвращает количество элементов в коллекции
toArray()			возвращает массив

Коллекция Set создана для хранения множества элементов. Поэтому ее так и называют Set (множество). У этой коллекции есть три 
особенности:

Операции над множеством
С множеством можно делать только три операции: добавлять элементы во множество, удалять элементы из множества и проверять, есть ли 
во множестве определенный элемент. Все.

Отсутствие порядка
У элементов этой коллекции нет номеров. Нельзя получить элемент по его индексу или записать значение в коллекцию по определенному 
индексу. Методов get() и set() у множества нет.

Уникальность элементов
Все элементы множества уникальны. В отличие от списка, во множестве один элемент может быть только раз. Объект или находится во 
множестве, или нет: третьего не дано. Нельзя во «множество цветов» трижды добавить «черный цвет». Он там либо есть, либо его нет.

Поиск элементов
Когда вы добавляете во множество новый элемент, удаляете элемент, или проверяете наличие элемента, внутри метода выполняется поиск 
элемента. Элементы коллекции и переданный элемент сравниваются сначала по hashCode(), а если hashCode() совпадают, по equals.
--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ EQUALS & HASHCODE ~~~~~~~~~~~~~~~~~~~~

Кроме метода equals, который выполняет детальное сравнение всех полей обоих объектов, есть еще один метод, который может использоваться
для неточного, но очень быстрого сравнения — hashCode(). А уже если хэши одинаковые, сравниваем equals.

имя instanceof Тип
Оператор instanceof проверяет, является ли переменная имя объектом типа Тип.

instanceof (перевод - экземпляр) -  нужен, чтобы проверить, был ли объект, на который ссылается переменная X, 
создан на основе какого-либо класса Y. // if (!(obj instanceof Person)) return false; 

Фишка instanceof в том, что он проверяет на равенстно объект этого же класса, либо наследника (даст тру), если сравнить является ли
родитель экземпляром наследника, выдаст фолс. А getClass сравнивает тупо класс к классу.

Но обычно все же объекты считаются равными, если это объекты одного класса. Поэтому если в наш метод equals передали объект не класса 
Person, мы будем всегда возвращать false. Похоже, что реально делается через getClass() != o.getClass()

Зачем преобразовывать объект типа Person к типу Person для сравнениея внутренности?
Затем, что когда мы переопределяем метод equals из класса Object через @Override он должен иметь те же параметры на вход, что и в
родительском классе (Object o), а значит мы принимаем некий объект, сами не знаем какой, то как мы будем сравнивать его поля? - через
явное приведение (даунгрейд).

1. Сначала проверяем не передан ли один и тот же объект, напримет Object a = new Object(); Object b = a;
if (this == obj) return true;

2. Потом проверяем, что переданный объект не null, т.к. мы вызываем метод у текущего объекта, значит он создан, значит не null
if (obj == null) return false;

3. Потом проверяем, что переданный объект того же класса, что и наш:
if (!(obj instanceof Person)) return false;
ЛИБО: getClass() != o.getClass()

4. Делаем даунгрейд переданного объекта до объекта, у которого вызвали метод, т.к. сначала передавался некий общий объект, поля не
сравнивались:
Person person = (Person) obj;

и проверяем поля:
if (this.age != person.age)
   return false;		//возраст без проверки на null

if (this.name == null) 		// если имя нулевое, проверить, что второе имя нулевое - тогда равны, 
   return person.name == null;	// т.е. Strign.equals() не может сравнивать null

return this.name.equals(person.name);	// и уже после проверок на null сравниваем name's
--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ИНТЕРФЕЙС ~~~~~~~~~~~~~~~~~~~~

В абстрактном родителе класса расширенного интерфейсом может быть переопределен метод интерфейса:
--------------------			----------------------
|    Abstract      |			|    Interface       |
|реализация метода |			|метод к переопред   |
-------------------			---------------------
		\			/
		  \		      /
		------------------------
		|обычн класс, наследник |
		|и интер и абстракт	|
		|а метод выполняется в	|
		|abstract		|
		-------------------------

Функциональный интерфейс - это интерфейс, который содержит всего один абстрактный метод. Других методов static or default может быть
сколько угодно, но абстрактный - один.

Стандартные методы интерфейса - public abstract.
Стандарнтые поля интерфейса - public static final.

Если класс абстрактный, то потомок обязан соотв всем его полям.
Если у абстрактного класса есть абстрактные методы (указ только сигнатура, без тела), то потомок обязан их иметь через переопределение.
Может быть идея интерфейса в том, что бы была возможность множественного наследования (требований), т.к. у одного класса интерфейсов 
может быть много. А еще идея в том, что абстрактный класс не может содержать все методы к переопределению для многих наследников, т.к.
не всем наследникам необходим этот полный набор. Дотачиваем интерфейсом.

 переменной с типом интерфейса можно присвоить объект любого класса, реализующего этот интерфейс (от себя: будут доступны только методы
объекта, объявленные в интерфейсе). Либо можно и стандарные методы объекта, но через явное пиведение. В общем, фишка в том, что если
мы создаем объект типа интерфейс, то он имеет доступ только к полям и методам интерфейса, к нашему объекту он доступа без приведения 
не имеет.

Разница абстрактного класса и интерфейса в том, что абстрактный класс определяет обязательные поля и методы для всех наследников 
(+ абстр класс может иметь свои неабстрактные и соотв необязательные к переопределению методы, но они должны тогда подходить для всех
наследников), а интерфейс для конкретного класса-наследника.

Итак, интерфейс - это по сути набор методов, которые наш класс обязан исполнять.



Поля интерфейса 
---------------
- это константы public static final, и поэтому их значение доступно из любого места программы.

public class Program{
      
    public static void main(String[] args) {
          
        WaterPipe pipe = new WaterPipe();
        pipe.printState(1);
    }
}
class WaterPipe implements Stateable{
     
    public void printState(int n){
        if(n==OPEN)
            System.out.println("Water is opened");
        else if(n==CLOSED)
            System.out.println("Water is closed");
        else
            System.out.println("State is invalid");
    }
}
interface Stateable{
 
    int OPEN = 1;
    int CLOSED = 0;
     
    void printState(int n);
}



Private методы
---------------
 могут использоваться только внутри самого интерфейса, в котором они определены.
То есть к примеру нам надо выполнять в интерфейсе некоторые повторяющиеся действия, и в этом случае такие действия можно выделить в 
приватные методы:

public class Program{
      
    public static void main(String[] args) {
          
        Calculatable c = new Calculation();
        System.out.println(c.sum(1, 2));
        System.out.println(c.sum(1, 2, 4));
    }
}
class Calculation implements Calculatable{
     
}
interface Calculatable{
 
    default int sum(int a, int b){
        return sumAll(a, b);
    }
    default int sum(int a, int b, int c){
        return sumAll(a, b, c);
    }
     
    private int sumAll(int... values){
         int result = 0;
         for(int n : values){
             result += n;
         }
         return result;
    }
}



default методы
-------------
 в интерфейсе используются, если класс, реализующий данный интерфейс, не реализует метод. Если реализует, переопределяем.



Наследование интерфейсов
------------------------
Интерфейсы, как и классы, могут наследоваться:


interface BookPrintable extends Printable{
     
    void paint();
}

При применении этого интерфейса класс Book должен будет реализовать как методы интерфейса BookPrintable, так и методы базового 
интерфейса Printable.
--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ АНОНИМНЫЙ КЛАСС ~~~~~~~~~~~~~~~~~~~~

Анонимные классы нужны для скрытого создания наследника какого-либо класса, в котором мы хотим что-то переопределить / изменить.
Применяется один раз к одному объекту (то есть можем присвоить его только одной переменной). Дальше уже используем "модифицированный" 
наследником класс.

Woman woman = new Woman(7) {			// в переменной woman лежит не отбъект класса woman, а объект класса-наследника
          int i = getBeautiful();		// с переопределенным методом

            @Override
            void sayGoodbye() {
                System.out.println("Goodby");
            }
        };


----------------------------------------------------

СОЗДАНИЕ ДУБЛИКАТА АНОНИМНОГО КЛАССА В СТАТИКЕ:

Consumer otherInstance = foo.getClass().newInstance();

СОЗДАНИЕ ДУБЛИКАТА АНОНИМНОГО КЛАССА В НЕСТАТИКЕ:

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.function.Consumer;

public class Anonymous {

    public void nonStaticMethod() {
        // собственно наш анонимный класс
        Consumer<String> foo = new Consumer() {
            @Override
            public void accept(Object o) {
                System.out.println(o + " TODO something useful!");
            }
        };

        foo.accept("Работа анонимного класса в НЕстатическом методе.");

        // достаем конструктор у анонимного класса
        Constructor[] constructors = foo.getClass().getDeclaredConstructors();
        // Записываем ссылку на объект Anonymous в массив параметров, для конструктора.
        Object[] params = new Object[1];
        params[0] = this;

        // Создаем новую ссылку типа Consumer
        Consumer otherInstance = null;
        try {
            // создаем новый экземпляр анонимного класса, передав в его конструктор массив параметров, ссылку на текущий
            // класс, в котором мы и осуществляем все манипуляции с анонимным классом.
            otherInstance = (Consumer) constructors[0].newInstance(params);
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

        otherInstance.accept("Работа второго экземпляра анонимного класса в НЕстатическом методе.");
    }

    public static void main(String[] args) {
        Anonymous anon = new Anonymous();
        anon.nonStaticMethod();
    }
}

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ АБСТРАКТНЫЙ КЛАСС ~~~~~~~~~~~~~~~~~~~~

Может быть либо public, либо package-private (по умолчанию).

Может иметь static и обычные поля: статик общий для всех наследников, как будто мы в каждом наследнике имеем это статик поле,
получаем доступ через класс Test1.q (q - статик переменная абстрактного класса), обычные поля абстрактного класса явл. св-вом
объекта, соотв. доступ ч/объект наследника.

Класс кошка и собака можно создать как обычные, можно создать объекты, они имеют действия. Класс животные - абстрактный, т.к. невозможно
создать объект животное. Интерфейс - это то, что класс умеет делать, а абстрактный класс - то чем класс является. Если класс содержит
хотя бы один абстрактный метод, такой класс должен быть абстрактным.

Использование абстракции — выделении общего поведения и свойств и заключении их в рамки абстрактного класса, или выделение только 
общего поведения – в таком случае мы создаем интерфейс. 

Абстрактный класс - это класс-описание. Он не может создавать свои объекты. От него можно наследоваться и создавать объекты
классов-наследников. Наследникам доступны как обычные, так и абстрактные методы абстрактного класса.

Почему абстрактный класс не обязан реализовывать методы интерфейса? Я так думаю, потому, что их должны реализовывать его наследники. 
То есть, если класс создает объекты, они должны соответствовать требованиям, а если класс каркас (абстрактный), объектов не создает,
то требования должны будут выполнять его потомки.

В чем разница между переопределением метода обычного класса наследнику и абстрактного класса наследнику?
В том, что абстрактный описывает модель, он еще не созрел для создания конкретных объектов.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ МОДИФИКАТОР
Классы могут быть только pubblic и package private (без указания модификатора).

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ПОЛУЧЕНИЕ ДОСТУПА К КЛАССАМ ~~~~~~~~~~~~~~~~~~~~


public class Test1 {
    public static void main(String[] args) {

    }
    public class B {
    }

    static public class C{
    }

    public class D extends Test1{
    }
}

class A extends Test1 {
}

Если просто класс (в нашем main другого класса):
Test1 test = new Test1();


Если к невложенному наследнику (A), то создаем объект класса-наследника типа родитель:
Test1 a = new A();              можно и просто A a = new A(); почему-то(?)


Если к обычному вложенному классу (B), то через переменную класса-обертки:
Test1 test = new Test1();
Test1.B b = test.new B();

Если к статическому подклассу (C), то без создания объекта класса-обертки:
Test1.C c = new Test1.C();

А если вложенный класс - это наследник (D), то так же как к обычному вложенному, через переменную класса-обертки:
Test1 test = new Test1();
Test1 d = test.new D();

То есть, когда обычный вложенный класс, то через объект обертки, а если вложенный static, без него. 
Статическим классом может быть только внутренний класс.

Итог: то, что является статичным принадлежит классу, мы можем получить к нему доступ без создания объекта.

Идея в том, что если подкласс обычный, то мы должны создавать экземпляр родителя, а если статик, то нет. Тогда получается, что главное
отличие наследника от вложенного в том, что вложенный может быть статиком, то есть быть создан без объекта класса-обертки. Обычные
вложенные и наследники одинаковы по сути (требуют создания объекта супер-класса) ПРОВЕРИТЬ, но если нужен будет объект чисто 
"наследника" (педали), то с обычным вложенным либо наследником мы не сможем его создать без родителя, а если сделаем статик, то можем.
+ к тому, улучшене инкапсуляции в связи с тем, что никто, кроме текущего разраба не видит возможность класса создавать подклассы и
какие, а так же их методы.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ ВНУТРЕННИЕ КЛАССЫ ~~~~~~~~~~~~~~~~~~~~

Внутренний класс - inner class
Вложенный класс - nested class (внутри нашего класса). Вложенный класс создается для того, чтобы обслуживать окружающий его класс.
По сути, вложенный класс и есть композиция - он живет только после создания объекта внешнего класса. Подобъект объекта.
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня.

Если сравнить внутренний класс с просто иным, то внутренний имеет доступ к полям и методам внешнего класса (вт.ч. private), 
но не может их переопределять, если не явл. наследником. Иной класс, доступа к полям и методам нашего класса не имеет - 
они никак не связаны. 

Конструктор внешнего класса при создании объекта внутреннего не вызывается, т.к. объект внешнего уже создан.

Больше всего внутренний класс похож на наследника - пользуется полями и методами внешнего, вт.ч. private поля / методы, (наследник 
через getter & setter), но! не может переопределять методы внешнего, однако ко внутреннему классу можно применить модиф доступа private, 
что улучш инкапс, т.к. в пакете его нет, а видимость ограничена внешним классом.

Если сравнить вложенного наследника и просто наследника, то, как я понимаю, они равны, просто у наследника лучше инкапс.

Внутренний класс является подобъектом объекта внешнего класса, но во внешнем классе вызывается просто как иной класс.

Статический внутренний класс принадлежит внешнему классу, можно создавать объект внутреннего без созд объекта внешнего. Он может исп.
только статик поля и методы внешнего.

Статический внутренний наследник внешнего может пользоваться всеми методами внешнего (вт.ч. нестатическими) + полями внешнего
(нестатическими через getter), но не может их (поля) изменять (если они не статик) - объекта же нет.

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ STATIC ~~~~~~~~~~~~~~~~~~~~
Обычный метод имеет модификатор this, указывающий на привязку к объекту. У статического такого нет. Поэтому ему недоступны все поля и 
методы объекта, т.к. нет ссылки на объект. 

Данный модификатор указывает на  привязку субъекта (поля например) к текущему классу.
При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу. 
Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу.
ТО, ЕСТЬ, если переменная static, это означает, что она принадлежит классу, а не объекту.

Статические поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса.
По идее статическое поле изменяемо, но оно одно для всех объектов. НО! Статическое поле можно изменить через класс.<имя_поля> либо
через объект (почему-то). 

Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.
Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам, но если это
поля/методы текущего класса. Если иные - пожалуйста.
Статические методы выполняются без создания объекта.
Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя 
лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility). Класс java.lang.Math — замечательный пример, 
в котором почти все методы статичны. Статические методы нельзя переопределять.

Статическим классом может быть только внутренний класс.

Если инициализатор конструктора статичный, то он вызовется только один раз.
Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.


Т.е. статические переменные (поля) и методы нужны для получения к ним доступа без создания объекта.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ РЕФЛЕКСИЯ ~~~~~~~~~~~~~~~~~~~~

Рефлексия дает возможность получения всех сведений о классах, их полях, конструкторах, методах, позволяет создавать объекты классов
динамически, т.е. после компиляции. Все классы являются экземплярами (объектами) класса Class. 

Для получения доступа к классу, с которым мы хотим взаимодействовать ч/рефлексию, необходимо создать его объект (экземпляр) класса.
Ну или получить ссылку на него (?, фактически, он же уже есть). 

Сделать это можно 3 способами (наш класс Person):
Class personClass = Person.class;
Class humanClass2 = Class.forName("hi_guys_package.Human");   //через <пакет.имя_класса>
Human h = new Human("Sergey", 36);
Class humanClass3 = h.getClass();	//через объект нашего класса.получить_класс

Методы объекта Class:
humanClass3.getField("name") - вывести поле name (если public) // выдаст: public java.lang.String hi_guys_package.Human.name
humanClass3.getFields() - вывести все поля (если public) // выдаст: [public java.lang.String hi_guys_package.Human.name, public int hi_guys_package.Human.age]
humanClass3.getDeclaredFields() - возвращает все поля (даже приватные)
humanClass2.getMethods() - возвращает методы класса (кроме приватных + переопределенные автоматом)
getReturnType() - получить возвращаемое методом значиение
getParameterTypes() - массив аргументов метода (тип)
humanClass2.getDeclaredMethods() - методы класса (вт.ч. приватные)
- если нужны только паблик методы, без авто-переопределенных, то:
Method[] methods = humanClass2.getDeclaredMethods();
        for (Method method: methods)
            if (Modifier.isPublic(Modifier.methodModifiers()))
            System.out.println(method.getName() + " " +
                    Arrays.toString(method.getParameterTypes()))
************все вышеуказанное применимо к конструкторам-----------


А можно взять поле, и детальнее с ним поработать:
Field idField = humanClass3.getField("name");
idField.getType() - вывести тип поля name	// выдаст: class java.lang.String

А можно создать массив полей и работать с ними (не зная названий):
Field[] humanFields = humanClass3.getFields();
for (Field f: humanFields)
    System.out.println(f.getName() + " " + f.getType());

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ IDEA'S HOT KEYS ~~~~~~~~~~~~~~~~~~~~

ALT + CTRL + L - форматирование по код-стайл
Shift + Tab - сдвиг влево 1 раз, можно несколько
ALt + Insert - Generate (Getter, setter, hashcode & equals)
Alt + Enter - бросить исключение, доп. действия
Ctrl + / - заккоментировать выделенную часть
CTRL + D - дублирование строки
fori - цикл for
ALT + CTRL + T - обернуть (try-catch)
CTRL + Y - удалить строку
SHIFT + F6 - переименовать переменную во всей программе


--------------------------------------------------------------------------------------------------
				~~~~~~~~~~~~~~~~~~   ООП    ~~~~~~~~~~~~~~~~~~~
1. Объект - это экземпляр класса. То есть есть класс, описывающий состояние и методы (действие) объекта, 
далее создаются конкретные объекты? - ДА, экземпляры класса.
2. Переменная - ссылка на новый объект, наделенный свойствами класса
3. Конструктор - инициализатор полей класса, т.е св-в объекта. Называется так же как класс. По сути это особенный метод,
который используется при создании нового объекта, просто так его не вызвать. В конструкторах отсутствует возвращаемый тип данных.
Конструктор не может быть void, т.к. в таком случае компилятор думает, что это метод.
4. This - ссылка на текущий объект в конструкторе. Т.е., если в main ссылкой на объект явл переменная, то в конструкторе this.
5. Сигнатура метода состоит из названия и списка парамеров (кот передаются в метод). Возвращаемый тип не входит в сигнатуру метода
6. Перезгрузка - все возможные варианты передачи параметров конструктору при создании объекта. Можно передавать различное
кол-во параметров не только конструктору, но и просто любому методу.
public class Jarvis {

    public void sayHi(String firstGuest) {
        System.out.println("Добрый вечер, " + firstGuest + ", как ваши дела?");
    }

    public void sayHi(String firstGuest, String secondGuest) {
        System.out.println("Добрый вечер, " + firstGuest + ", " + secondGuest + ", как ваши дела?");
    }

    public static void main(String[] args) {
        Jarvis jarvis = new Jarvis();
        jarvis.sayHi("Тони Старк");
        jarvis.sayHi("Тони Старк", "Капитан Америка");
6.1. Можно делать перегрузку с неизвестным количеством входных данных via "..." и выводить через for (по сути массив?).
public class Jarvis {

    public void sayHi(String...names) {
        for (String name: names) {
            System.out.println("Добрый вечер, " + name + ", как ваши дела?");
        }
    }

    public static void main(String[] args) {
        Jarvis jarvis = new Jarvis();
        jarvis.sayHi("Тони Старк", "Капитан Америка", "Черная Вдова", "Халк");
    }
}

7. Модификатор доступа ставятся над классом, над полями, над методом. 
Стандортно - *public, доступен во всей программе. 
Package private доступен только в пределах пакета. Если явно не указать его (например void <method name> ()), то по умолчанию
будет Package private. НЕ ПРОПИСЫВАЕТСЯ, УСТАНАВЛЯВАЕТСЯ АВТОМАТИЧЕСКИ ПРИ ОТСУТСТВИИ МОДИФИКАТОРА ДОСТУПА.
*private - доступ только внутри класса.
*protected - доступ в пределах пакета (as package private) + наследники.
* - прописываются
ДЛЯ КЛАССОВ МОЖЕТ БЫТЬ ТОЛЬКО ДВА МОД ДОСТУПА: ПАБЛИК ЛИБО ПЭКЕДЖ ПРАЙВИТ (если не указываем)
8. Геттер получает значение поля private, а сеттер изменяет? Разве нельзя это сделать внутри просто присваиванием?
9. По идее, можно в мэйн создавать экземпляр текущего класса (в коротом работаешь, где и расположен сам мэйн).
10. Когда оператор == применяется к объектам, он фактически сравнивает ссылки на объекты а не сами объекты. Т.е. переменная
является ссылкой, а не значением объекта. Для получения значения вызвать intValue().
11. Полиморфизм - это переопределение методов родительского класса в зависимости от типа класса-наследника.
12. Переопределение - это либо переопределяем метод (конкретные действия) в классе-наследнике через @Override, 
либо просто прописываем их в суперклассе (?)да\нет? переопределение позволяет взять какой-то метод родительского класса и 
написать в каждом классе-наследнике свою реализацию этого метода. Новая реализация «заменит» родительскую в дочернем классе.
12.1. У переопределенного метода должны быть те же аргументы (параметры), что и у метода родителя
12.2. У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
12.3. Модификатор доступа у переопределенного метода также не может отличаться от «оригинального»
12.4. Также слово final можно применять к методам, чтобы предотвратить его переопределение
12.5. Ещё один вариант использования ключевого слова final — предотвращение наследования класса. final class Tail {} -
не может быть супер-классом
12.6. Все, что нужно знать о конструкторе и инициализаторе:

public static void main(String[] args) {
         
        Person undef = new Person();
        undef.displayInfo();
         
        Person tom = new Person("Tom");
        tom.displayInfo();
    }
}
class Person{
     
    String name;    // имя
    int age;        // возраст
     
    /*начало блока инициализатора*/
    {
        name = "Undefined";
        age = 18;
    }
    /*конец блока инициализатора*/
    Person(){
         
    }
    Person(String name){
         
        this(name, 18);
    }
    Person(String name, int age){
         
        this.name = name;
        this.age = age;
    }
    void displayInfo(){
        System.out.printf("Name: %s \tAge: %d\n", name, age);
    }


--------------------------------------------------------------------------------------------------
				~~~~~~~~~~ ENUM ~~~~~~~~~~~~

Кроме отдельных примитивных типов данных и классов в Java есть такой тип, как enum или перечисление. 
Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора enum, 
после которого идет название перечисления.

enum Day{
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}

Мы можем создать переменную типа Day и присвоить ей значение Day (из списка):
Day arg = Day.MONDAY;

А если через массив, то все значения списка (via values()):
Day[] arr = Day.values();

Можно пользоваться for-each (не обязательно создавать массив перед этим):
for (Day s: Day.values())
            System.out.println(s);

Конструктор в enum - это по-сути свойство объекта перечисления. Так же как в обычных классах у объектов могут быть свойства,
у каждого объекта-перечисления enum есть свое свойство (значиние).
Можно задавать не один, а несколько параметров перечисляемому объекту:
MONDAY("Понедельник", 1) - потом нужно сделать конструктор для нескольких параметров.

Если при создании объекта, мы указываем ЛЮБЫЕ св-ва его полей в момент объявления/инициализации new Obj (1,2,3), то в enum
они строго ограничены конктерным св-вом объекта перечисления - создаются в момент создания класса enum, значения передаются
переменным (полям) класса (enum) через конструктор.

Для использования switch:
---------------------------------------

Day d = Day.MONDAY; // без инициализации не работает

Методы:
values() возвращает массив всех значений типа enum:
----------------------------------------

Day[] days = Day.values();

    for (Day s: days.values())
        System.out.println(s); // выводит все значения

Метод ordinal() возвращает порядковый номер константы. Вызывать его нужно не у класса enum, а у значения enum:
----------------------------------------
System.out.println(Day.MONDAY.ordinal()); // 0


Для получения объекта по порядковуму нормеру нужно:
Day day = Day.values()[2];

--------------------------------------------------------------------------------------------------
				
--------------------------------------------------------------------------------------------------
				~~~~~~~~~~ СИСТЕМЫ СЧИСЛЕНИЯ ~~~~~~~~~~~~

Двоичная 0b, for instance: 0b1000_0001

Восьмиричная представляется как 0 и далее число -> 09 например. В десятичной системе счисление представление числа с 0 впереди
недопустимо и вызовет ошибку компиляции, т.к. это число в восьмиричной системе, а 9 в ней отсутствует.

Шестнадцатиричная система представляется как 0x и далее число. Можно представить в экспоненте, где р - показатель степени двойки.
0xFp2 // 15x22=60

Integer.toHexString(i) - из десятичной в шестнадцатеричную
Integer.toOctalString(i) - из десятичной в восьмиричную
Integer.toBinaryString(i) - из десятичной в двоичную

Integer.parseInt("11101000", 2); - из двоичной в десятичную
Integer.valueOf("100", 2); - из двочной в десятичную

--------------------------------------------------------------------------------------------------
			~~~~~~~~~~~~~~~~~~~~~~ КОДИРОВКИ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Изначально ASCII определял 7 бит 128 символов (с учетом 0), но занимал 8 бит (знак числа). 
Потом появился расширенный ASCII до 8 бит 256 символов (8859-1, также называемый ISO Latin-1).
ASCII и Unicode равны в первых 128 символов.

История Unicode:
1. UTF-8
2. UTF-16 (миллион символов)
3. UTF-32 не используется

Unicode - это расширение кодировки, известной как UTF-8, которая, в свою очередь, основана на старом 8-битном расширенном 
стандарте ASCII, который, в свою очередь, содержит самый старый стандарт, ASCII

Кодовая единица в US-ASCII состоит из 7 бит;
Кодовая единица в UTF-8, EBCDIC и GB 18030 состоит из 8 бит;
Кодовая единица в UTF-16 состоит из 16 бит;
Кодовая единица в UTF-32 состоит из 32 бит.

UTF-8 и UTF-16 - это всего лишь два из установленных стандартов кодирования. Они отличаются только количеством байтов, 
используемых для кодирования каждого символа. Поскольку оба являются кодировками переменной ширины, они могут использовать 
до четырех байт для кодирования данных, но когда дело доходит до минимума, UTF-8 использует только один байт (8 бит), 
а UTF- 16 использует 2 байта (16 бит).

Java supports US-ASCII, ISO-8859-1, UTF-8 и UTF-16, и это лишь некоторые из них. 
Конкретная реализация Java может опционально поддерживать дополнительные кодировки.

Unicode записывается в шестнадцатиричной сс System.out.println((char) 0xF00F); - 65,536 символов (with zero);
А если вывести  правильно в char - System.out.println('\u0069');

ASCII - 1 byte = 8 bits
UNICODE - 2 bytes = 16 bits (65.535) и более

char хранит только положительные значения от 0 до 65.535

\u0069\u006E\u0074 \u0069 \u003D \u0038\u003B
		=
        System.out.println(i);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------

import java.util.Scanner;

class MyClass {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(sc.nextLine());
	sc.close();
    }
}

Scanner sc = new Scanner(System.in).useDelimiter("d"); - использовать иной разделитель (не пробел)

Ввести объект int: nextInt()
Ввести объект float: nextFloat()
Ввести объект double: nextDouble()
Ввести объект boolean: nextBoolean()
Ввести строку целиком: nextLine()
Ввести слово (считывается до первого пробела): next()
Первая буква слова: char ch1 = sc.next().charAt(0), ch2 = sc.next().charAt(0);

Если ипользуется только 1 раз: int n = new Scanner(System.in).nextInt();

hasNext() - поток ввода данных Ctrl + D

hasNextInt() — метод проверяет, является ли следующая порция введенных данных числом, или нет 
(возвращает, соответственно, true или false).

hasNextLine() — проверяет, является ли следующая порция данных строкой.

hasNextByte(), hasNextShort(), hasNextLong(), hasNextFloat(), hasNextDouble() — все эти методы делают то же для остальных 
типов данных.

if (sc.hasNextInt()) {
           int number = sc.nextInt();
           System.out.println("Спасибо! Вы ввели число " + number);
       } else System.out.println("Извините, но это явно не число. Перезапустите программу и попробуйте снова!");

Еще один важный метод, на который стоит обратить внимание — useDelimiter().
В этот метод передается строка, которую вы хотите использовать в качестве разделителя.

--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~CHAR~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------------------------
Чтобы привести символ `char` к целому числу `int` в Java, можно использовать статический метод `getNumericValue()` 
из класса `Character`. Этот метод возвращает числовое значение символа:

Character.getNumericValue('5'); // 5
Character.getNumericValue('0'); // 0
Буквы A-Z будут иметь числовое значение от 10 до 35:

Character.getNumericValue('a'); // 10
Если символ не имеет числового представления, вернётся -1:

Character.getNumericValue('?'); // -1


--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~STRINGBUFFER AND STRINGBUILDER~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------------------------

Чтобы получить строку, которая хранится в StringBuffer, мы можем использовать стандартный метод toString():

String str = "Java";
StringBuffer strBuffer = new StringBuffer(str);
System.out.println(strBuffer.toString()); // Java
По всем своим операциям StringBuffer и StringBuilder напоминают класс String.

--------------------------------------------------------------------------------------------------

Получение и установка символов
Метод charAt() получает, а метод setCharAt() устанавливает символ по определенному индексу:

StringBuffer strBuffer = new StringBuffer("Java");
char c = strBuffer.charAt(0); // J
System.out.println(c);
strBuffer.setCharAt(0, 'c');
System.out.println(strBuffer.toString()); // cava

--------------------------------------------------------------------------------------------------

Метод getChars() получает набор символов между определенными индексами:

StringBuffer strBuffer = new StringBuffer("world");
int startIndex = 1;
int endIndex = 4;
char[] buffer = new char[endIndex-startIndex];
strBuffer.getChars(startIndex, endIndex, buffer, 0);
System.out.println(buffer); // orl

--------------------------------------------------------------------------------------------------

Добавление в строку
Метод append() добавляет подстроку в конец StringBuffer:

StringBuffer strBuffer = new StringBuffer("hello");
strBuffer.append(" world");
System.out.println(strBuffer.toString()); // hello world

--------------------------------------------------------------------------------------------------

Метод insert() добавляет строку или символ по определенному индексу в StringBuffer:

StringBuffer strBuffer = new StringBuffer("word");
         
strBuffer.insert(3, 'l');
System.out.println(strBuffer.toString()); //world
 
strBuffer.insert(0, "s");
System.out.println(strBuffer.toString()); //sworld

--------------------------------------------------------------------------------------------------

Удаление символов
Метод delete() удаляет все символы с определенного индекса до определенной позиции, 
а метод deleteCharAt() удаляет один символ по определенному индексу:

StringBuffer strBuffer = new StringBuffer("assembler");
strBuffer.delete(0,2);
System.out.println(strBuffer.toString()); //sembler
         
strBuffer.deleteCharAt(6);
System.out.println(strBuffer.toString()); //semble

--------------------------------------------------------------------------------------------------

Обрезка строки
Метод substring() обрезает строку с определенного индекса до конца, либо до определенного индекса:

StringBuffer strBuffer = new StringBuffer("hello java!");
String str1 = strBuffer.substring(6); // обрезка строки с 6 символа до конца
System.out.println(str1); //java!
         
String str2 = strBuffer.substring(3, 9); // обрезка строки с 3 по 9 символ 
System.out.println(str2); //lo jav

--------------------------------------------------------------------------------------------------

Изменение длины
Для изменения длины StringBuffer (не емкости буфера символов) применяется метод setLength(). 
Если StringBuffer увеличивается, то его строка просто дополняется в конце пустыми символами, если уменьшается - 
то строка по сути обрезается:

StringBuffer strBuffer = new StringBuffer("hello");
strBuffer.setLength(10);
System.out.println(strBuffer.toString()); //"hello     "
         
strBuffer.setLength(4);
System.out.println(strBuffer.toString()); //"hell"

--------------------------------------------------------------------------------------------------

Замена в строке
Для замены подстроки между определенными позициями в StringBuffer на другую подстроку применяется метод replace():

StringBuffer strBuffer = new StringBuffer("hello world!");
strBuffer.replace(6,11,"java");
System.out.println(strBuffer.toString()); //hello java!
Первый параметр метода replace указывает, с какой позиции надо начать замену, второй параметр - до какой позиции, 
а третий параметр указывает на что меняем.

--------------------------------------------------------------------------------------------------

Обратный порядок в строке
Метод reverse() меняет порядок в StringBuffer на обратный:

StringBuffer strBuffer = new StringBuffer("assembler");
strBuffer.reverse();
System.out.println(strBuffer.toString()); //relbmessa


--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------------------------

То, что в скобках [] - мы меняем. Если ставим XOR ^, то наоборот - оставляем:

String name = "Was it a cat I saw?123";
sout(name.replaceAll([0-9])); 	// Was it a cat I saw?
sout(name.replaceAll([^0-9])); 	// 123

Regex	Значение
[^a-zA-Z0-9] - найти все, кроме симловов и цифр
[a-zA-Z0-9] - найти символы и цифры

"[\\p{Punct}\\s]+" 	- удаление всех символов кроме слов и пробелов. Получатся только слова через пробел
\p{Punct} 		эквивалентен [!"#$%&'()*+,-./:;<=>?@[\]^_``{|}~]
\\s 			Это символьный класс, который соответствует любому пробельному символу, такому как пробел, табуляция, 
			новая строка и т. д.
+: 			Это квантификатор, который указывает, что предыдущий символ или символьный класс должен встречаться один или 
			более раз


^ начало строки
$ конец строки
. любой символ
\\d	Любая цифра (эквивалентно [0-9])
\\D	Любой символ, кроме цифр
\\s	Символ пробела. Это эквивалентно символьному классу [ \t\n\x0B\f\r] и соответствует любому пробельному символу, включая пробел, 
	табуляцию, перенос строки и т. д.
\\S	Любой символ, кроме пробела.
\\w	буквенный, цифровой или подчеркивание
\\W	наоборот
\\b	Соответствует границе слова, где символом слова является [a-zA-Z0-9_]
\\B	Соответствует границам символов, не являющихся словами
\\G	Точка предыдущего соответствия
\p{L} 	Это Unicode-свойство, которое соответствует любой букве в любом языке. Это включает в себя буквы в верхнем и нижнем регистрах, 
	а также буквы с акцентами и диакритическими знаками.

ИНОГДА ЧЕРЕЗ ОДНИН СЛЕШ \ !!!!!!!!!!!!!!!!!!!

() - группа, например, "(\\+375)? - может не быть, либо быть 1 раз, показывает, где начинается и заканчивается группа
[] - перечисление, либо то, то используется [абв] — только «а», «б» или «в», либо диапазон [0-9], НО! только для одного символа
не [1-31], т.к. будет от 1 до 3
^ - начало строки
$ - конец строки
\\2 - значение символа должно быть равным значению номера группы (в данном случае 2)
?<code> - задает название группе
?: - исключение группы

Эти 2 варианта вернут одно и то же:

А(н|л)я
А[нл]я

+ ожидаем встретить символ один или более раз
* ноль или более раз
? или ноль или один раз
{n} ровно n раз
{n, m} от n до m раз
{m,} не менее m
{,n} не более n

| - или, пишется выражение в скобках   ^(Тайланд|тайланд|Таиланд|таиланд)$	^Agent 00(1|2|3|4|5|6|7|8|9|0)$

^[Тт]а[иЙ]ланд$ - символьные классы, так же все виды Тайланда подойдут
^Agent 00[1-7] - все агенты от одного до семи
^Agent 00[^089] - все агенты, кроме 0, 8, 9

Можно вызвать как (String email):
Pattern patt = Pattern.compile("[A-Za-z0-9]+@(gmail|outlook)\\.com");
Matcher match = patt.matcher(email);
match.matches();						//true || false

Pattern.matches("[A-Za-z0-9]+@(gmail|outlook)\\.com", email);	//true || false

email.matches("[A-Za-z0-9]+@(gmail|outlook)\\.com");		//true || false

matcher.find() - каждый вызов метода переводит далее по строке в поиске соотв. элемента
matcher.group() - возвращает текущий найденный элемент в виде строки
while (matcher.find())
	sout(matcher.group);


https://habr.com/ru/articles/545150/
https://regex101.com/
--------------------------------------------------------------------------------------------------

Что бы осуществить перебор, нужно использовать find():


--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~СТРОКИ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------------------------

.intern()
Добавляет строку в пул, если объект был создан не через автоупаковку.
String s3 = new String("reb").intern();

Метод repeat(int n)

--------------------------------------------------------------------------------------------------

Метод repeat просто повторяет текущую строку n раз. Пример:

Код	Результат
"Привет".repeat(3); // "ПриветПриветПривет"
"Привет".repeat(2); // "ПриветПривет"
--------------------------------------------------------------------------------------------------

Конкатенация

В большинстве языков программирования складывать можно не только числа, но и строки. Сложение строк называется конкатенацией. 
В результате конкатенации получается также строка: это первая строка, соединенная со второй строкой.

String firstWord, secondWord;
firstWord = "Hello";
secondWord = "World";
System.out.println(firstWord + secondWord); //HelloWorld

--------------------------------------------------------------------------------------------------

Еще один метод объединения - метод join() позволяет объединить строки с учетом разделителя. Например, выше две 
строки сливались в одно слово "HelloWorld", но в идеале мы бы хотели, чтобы две подстроки были разделены пробелом. 
И для этого используем метод join():

String str1 = "Java";
String str2 = "Hello";
String str3 = String.join(" ", str2, str1); // Hello Java
Метод join является статическим. Первым параметром идет разделитель, которым будут разделяться подстроки в общей строке, 
а все последующие параметры передают через запятую произвольный набор объединяемых подстрок - в данном случае две строки, 
хотя их может быть и больше

--------------------------------------------------------------------------------------------------

Получение индекса элемента в строке. int x = word.indexOf('b'); Если элемент не найден, метод возвращает -1.

--------------------------------------------------------------------------------------------------
Получение элемента строки по его индексу. char letter_0 = word.charAt(0); 
метод возвращает значение типа char, а не String.
--------------------------------------------------------------------------------------------------

Длина строки (количество символов). 0 не считает.

str.length();      // возвращает длину строки str (количество символов, включая пробелы)

String word = "Java is strong";
int x = word.length();
System.out.println(x);
--------------------------------------------------------------------------------------------------
Сравнение строк.

В Java строки нельзя сравнивать с помощью операторов сравнения, таких как == и !=. Вернее, сравнивать-то можно, но результат Вас удивит ;) Для корректного сравнения 
строк необходимо использовать специальный метод:

str1.equals(str2); // Сравнивает строки str1 и str2
Этот метод является булевым, то есть возвращает true, если строки равны, и false, если нет.

String word1 = "Java";
String word2 = "Python";
System.out.println(word1.equals(word2)); // false

String word3 = "Ja";
String word4 = "va";
boolean result = word1.equals(word3 + word4); 
System.out.println(result); // true
--------------------------------------------------------------------------------------------------

Если надо извлечь сразу группу символов или подстроку, то можно использовать метод 
getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin). Он принимает следующие параметры:

srcBegin: индекс в строке, с которого начинается извлечение символов

srcEnd: индекс в строке, до которого идет извлечение символов

dst: массив символов, в который будут извлекаться символы

dstBegin: индекс в массиве dst, с которого надо добавлять извлеченные из строки символы

String str = "Hello world!";
int start = 6;
int end = 11;
char[] dst=new char[end - start];
str.getChars(start, end, dst, 0);
System.out.println(dst); // world

--------------------------------------------------------------------------------------------------
Получение индекса элемента в строке.

Метод indexOf() ищет в строке заданный символ (или строку), и возвращает  индекс его первого вхождения. 
Если элемент не найден, метод возвращает -1.

String word = "abracadabra";
int x = word.indexOf('b');
System.out.println(x); // 1

int y = word.indexOf('Z');
System.out.println(y); // -1
--------------------------------------------------------------------------------------------------

lastIndexOf() - индекс последнего вхождения элемента в строку. Если подстрока не будет найдена, то оба метода возвращают -1:

String str = "Hello world";
int index1 = str.indexOf('l'); // 2
int index2 = str.indexOf("wo"); //6
int index3 = str.lastIndexOf('l'); //9

--------------------------------------------------------------------------------------------------
Получение элемента строки по его индексу.

Для этого используется метод charAt():

String word = "abracadabra";

char letter_0 = word.charAt(0);
System.out.println(letter_0); // a

char letter_4 = word.charAt(4);
System.out.println(letter_4); // c
Обратите внимание - метод возвращает значение типа char, а не String. Индексация, как обычно, начинается с нуля.
--------------------------------------------------------------------------------------------------

Проверка строки на пустоту.

Метод isEmpty() является весьма полезным инструментом. Он возвращает false, если строка содержит какие-либо элементы (пробел - тоже элемент), и true - если строка 
пустая, т.е. не содержит ни одного элемента.

String str1 = "Hubba Bubba";
String str2 = "   ";
String str3 = "";

boolean value1 = str1.isEmpty(); // false
boolean value2 = str2.isEmpty(); // false
boolean value3 = str3.isEmpty(); // true

--------------------------------------------------------------------------------------------------
 Одна строка внутри другой

Чрезвычайно полезный метод contains() проверяет, содержится ли одна строка внутри другой, и возвращает соответствующее логическое значение - true или false.

String str1 = "One Two Three";
String str2 = "One";
String str3 = "Four";

boolean value1 = str1.contains(str2); // true
boolean value1 = str1.contains(str3); // false
--------------------------------------------------------------------------------------------------
Преобразование регистров.

Методы  toUpperCase() / toLowerCase() приводят всю строку в верхний и нижний регистр соответственно.

String s = "I'll be back";

System.out.println(s.toLowerCase()); // i'll be back
System.out.println(s.toUpperCase()); // I'LL BE BACK
--------------------------------------------------------------------------------------------------
Представление числа в строковом формате. Иногда полезно работать не с числом, а с его представлением в виде строки. 
Для этого Java предоставляет метод toString(). Чтобы использовать этот метод, нужно воспользоваться 
классом - обёрткой Integer. Сделать это можно разными путями.

int n = 12345;                      // Это число типа int
System.out.println(n);              // 12345 

String str1 = Integer.toString(n);  // Это строка
System.out.println(str1);           // 12345

Integer num = n;                    // Это число-объект класса Integer
System.out.println(num);            // 12345

String str2 = num.toString();        // Это строка
System.out.println(str2);            // 12345

Похоже, что представление идет через int, для long использовать Long.toString()
--------------------------------------------------------------------------------------------------
Преобразование строки в число.

Метод, обратный предыдущему - valueOf() преобразует строку в число нужного типа.

String str = "12345";
Integer num = Integer.valueOf(str);  // num - объект класса Integer
System.out.println(num);             // 12345

int num1 = num;                      // num1 - переменная типа int
System.out.println(num1);            // 12345

Поскольку оба метода (toString() и valueOf()) - это методы класса Integer, то именно с объектами этого класса их и необходимо использовать. 
Подробнее о типах переменных и их взаимоотношениях мы коснёмся в следующих модулях.

Есть и ещё один, более простой метод преобразования строки в число - parseInt(), также принадлежащий классу Integer.

String str = "12345";

int num = Integer.parseInt(str);    //num - переменная типа int
System.out.println(num);            //12345

Если нужно преобразовать строку в число с плавающей точкой, можно использовать соответствующий метод из класса Double.

String str = "12345";

double num = Double.parseDouble(str);    //num - переменная типа double
System.out.println(num);                 //12345.0
--------------------------------------------------------------------------------------------------
Создание подстроки.

Метод substring() возвращает новую строку, которая является подстрокой данной строки. Подстрока начинается с символа, 
заданного индексом, и продолжается до конца данной строки или до указанного индекса.

String str = "Добро пожаловать в мир Java!";

System.out.println(str.substring(6));         //пожаловать в мир Java!

System.out.println(str.substring(6, 15));     //пожаловат
--------------------------------------------------------------------------------------------------
Замена элементов строки. replace () - меняет все буквы на новые

Несмотря на то, что строки в Java являются неизменяемыми (immutable), всё-таки их можно изменять с помощью специального 
метода replace(), который может заменить один символ на другой. Этот метод не изменяет строку, а собирает новую по заданным 
параметрам. Метод принимает два обязательных параметра - символ, подлежащий замене, и символ, на который его нужно заменить.
А может и множество символов.

String str = "Добро пожаловать в мир Java!";

System.out.println(str.replace('о', 'А')); //ДАбрА пАжалАвать в мир Java!
Обратите внимание - метод работает с заменой символов (char), о чём говорят одинарные кавычки.

String str = "Hello world";
String replStr2 = str.replace("Hello", "Bye"); // Bye world
--------------------------------------------------------------------------------------------------
Метод replaceAll() – заменяет каждую подстроку данной строки, которая соответствует заданному регулярному выражению, 
с данной заменой, другими словами – метод позволяет заменить слова в строке.
--------------------------------------------------------------------------------------------------
Метод replaceFirst() – заменяет ТОЛЬКО первую подстроку данной строки, которая соответствует заданному регулярному выражению, 
с данной заменой, другими словами – метод в Java позволяет заменить первое вхождение слова или словосочетания в строке.
--------------------------------------------------------------------------------------------------
Арифметические операции + строка

При обработке выражения все переменные, находящиеся после первого значения типа String, будут автоматически преобразованы в строку. 
Обращайте внимание на порядок аргументов:

int x = 10, y = 15;

System.out.println(x + 1 + " не равно " + y);   //11 не равно 15
System.out.println(x + " не равно " + y + 1);   //10 не равно 151
System.out.println(x + " не равно " + (y + 1)); //10 не равно 16
--------------------------------------------------------------------------------------------------
Преобразовать строку в массив символов

С помощью метода toCharArray() можно обратно преобразовать строку в массив символов:
String str1 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
char[] helloArray = str1.toCharArray();


--------------------------------------------------------------------------------------------------

.startWith("xx"); - начинается ли строка с определенной подстроки
.endWith("xx"); - заканчивается ли строка определенной подстрокой

--------------------------------------------------------------------------------------------------

Прим (STRINGS):
1. Можно присвоить строке массив символов:
    String str3 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
    String str4 = new String(new char[]{'w', 'e', 'l', 'c', 'o', 'm', 'e'}, 3, 4); //3 -начальный индекс, 4 -кол-во символов
    System.out.println(str3); // hello
    System.out.println(str4); // come

2. При присваивании, присваивается ссылка, а не значение. s1 = s2;

--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~УСЛОВНЫЕ ОПЕРАТОРЫ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------------------------


Условные операторы && ect

& Логическое И
| Логическое ИЛИ
|| Короткозамкнутое ИЛИ
^ Логическое исключающее ИЛИ
&& Короткозамкнутое И
! Логическое ударное НЕ
== равно
!= не равно

Мы расположили логические операторы в списке тем выше, чем выше их приоритет: 
!
&
^
|
&&
||

--------------------------------------------------------------------------------------------------
Тернарный оператор

int x = 15;

System.out.println((x % 2 == 0) ? "Число чётное" : "Число нечётное");

Можно дважды if - else в одной строке:
 System.out.println((num%5 == 0) ? "NO" : (num%7 == 0) ? "YES" : "NO");

Нахождение максимального \ минимального:

        max = a>=b && a>=c ? a : b>=a && b>=c ? b : c;
        min = a<=b && a<=c ? a : b<=a && b<=c ? b : c;
--------------------------------------------------------------------------------------------------
математические операции и операции сравнения производятся ДО логических операций

boolean a = true;
boolean b = false;
int c = 30;
int q = 5;

boolean r = (a || b && c >= 25) || (c < 20 * q) && !(q == 5);

c >= 25 - true 
b && c - false && true == false
a || b - true || false = true

c < 20 * q - true
!(q == 5) - false
(c < 20 * q) && !(q == 5) - false

true || false

--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SWITCH  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
--------------------------------------------------------------------------------------------------

Могут использоваться следующие типы: String, char, int;

Оператор switch - Это очень удобная конструкция для выбора каких-либо действий по конкретным флагам. 
Конструкция проверяет переменную на равенство с определённым заранее списком значений. 

Синтаксис:

switch (выражение) {
    case  value1:
        //Группа команд
        break; 

    case value2 :
        //Группа команд
        break; 
    
    ... //Можно вставить столько проверяемых значений, сколько нужно

    default: //Необязательно
       //Группа команд, исполняемая, если значение выражения не рано ни одному из случаев
}

EXAMPLE:
int a = 11; 
int b = 12; 
int c = 42;

switch (a) {
    case 40:
        System.out.println(b);
        break;
    default:
        System.out.println(с);
}

Блок команд в каждом случае завершается командой break. Эта команда завершает исполнение всей конструкции switch, и начинается исполнение кода, 
расположенного после неё. Вообще говоря, команда break необязательна, однако её отсутствие приведёт к тому, что выполнится и следующий блок команд

Использование команды default также не является обязательным. 
Тогда, если switch не нашёл соответсвия выражения ни одному из случаев, программа просто перейдёт к исполнению кода, расположенного ниже.

что в случае, если switch нашёл соответствие аргумента, но в конце группы команд не стоит "break", то default так же будет выполнен 
сразу как закончит выполнение case-блока

 case 12: case 1: case 2:
System.out.println("Зима");
    break;

    case 3: case 4: case 5:
System.out.println("Весна");
    break;

--------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ЦИКЛЫ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--------------------------------------------------------------------------------------------------
int x = 3;				~~WHILE~~ / ~~DO - WHILE~~~

while (x > 0) {
    System.out.println(x);
    x--;
}

В дополнение к циклу while существует также циклическая конструкция do ... while. Она отличается от "обычного" цикла лишь тем,
 что проверка условия происходит не в начале, а в конце тела цикла. Таким образом, тело цикла исполняется, как минимум, 
один раз.

int x = 1;
do {
    System.out.println(x);
    x++;
} while (x < 0);

// 1

continue - back to the cycle's start
break - terminates cycle

while (true) {
            x++;
            if (x % 2 == 0) continue;
            System.out.println(x);
            if (x == 5) break;
        }
--------------------------------------------------------------------------------------------------
						~~~~~~ FOR ~~~~~~~~~

Если известно точное количество повторений цикла, более удобно использовать другой цикл - for. Синтаксис:

for (инициализация; условие; счётчик (выполнятеся после блока команд)) {
    блок команд;
}

for (int i = 1; i <= 5; i++) {
    System.out.println(i);
}

Обратите внимание - после окончания работы цикла переменная i исчезает, за пределами фигурных скобок она не существует. 

А можно и так: for (int i = 0; i++ < 10; System.out.println("Отлично!"));

Счетчик после блока команд:
for (int i = 5; i < 10; i += 2) {
    System.out.print(i + " "); // 5 7 9
}


------------------------------------------Операторы continue и break
Оператор break позволяет выйти из цикла в любой его момент, даже если цикл не закончил свою работу:

Например:

for (int i = 0; i < 10; i++){
    if (i == 5)
        break;
    System.out.println(i);
}
Когда счетчик станет равным 5, сработает оператор break, и цикл завершится.

Теперь сделаем так, чтобы если число равно 5, цикл не завершался, а просто переходил к следующей итерации. Для этого используем оператор continue:

for (int i = 0; i < 10; i++){
    if (i == 5)
        continue;
    System.out.println(i);
}
В этом случае, когда выполнение цикла дойдет до числа 5, программа просто пропустит это число и перейдет к следующему.
--------------------------------------------------------------------------------------------------
					~~~~~~~~~~~~  ПАУЗА ~~~~~~~~~~~~~~

Thread.sleep(время);
Где время — это длина паузы в миллисекундах (1/1000 часть секунды).

Исполнение такой команды приостановит вашу программу на время миллисекунд. Примеры:

Thread.sleep(2000);
Приостановит программу на 2 секунды.
Thread.sleep(500);
Приостановит программу на полсекунды.
Thread.sleep(60 * 60 * 1000);
Приостановит программу на 1 час.

--------------------------------------

Класс TimeUnit
Кстати, в Java есть еще один класс, который облегчит вашу жизнь, если вы таки решите сделать ваше приложение еще медленнее — 
это класс TimeUnit из пакета java.util.concurrent.

Этот класс делает то же самое, что и Thread.sleep(), просто удобнее:

TimeUnit.HOURS.sleep(15)
Этот код усыпит вашу программу на 15 часов. Также доступны минуты, секунды, дни.  А еще — микросекунды (1/1000,000) и 
наносекунды (1/1000,000,000).

У класса TimeUnit есть такие свойства:

наносекунды: NANOSECONDS
микросекунды: MICROSECONDS
миллисекунды: MILLISECONDS
секунды: SECONDS
минуты: MINUTES
часы: HOURS
дни: DAYS

--------------------------------------------------------------------------------------------------
					~~~~~~~~~~~~  RANDOM ~~~~~~~~~~~~~~

Требует создания объекта.  Random rand = new Random();

double nextDouble()
Этот метод возвращает случайное вещественное число в диапазоне 0.0 – 1.0. Очень похоже на метод Math.random(). 
И ничего удивительного, ведь метод Math.random() просто вызывает метод nextDouble() у объекта типа Random.

int nextInt(int max)
Этот метод возвращает случайное целое число в диапазоне [0, max). 0 входит в диапазон, max — не входит.
Т.е. если вы хотите получить случайное число из набора 1, 2, 3, 4, 5, 6, вам нужно будет прибавить к полученному случайному числу 
единицу.

boolean nextBoolean()
Этот метод возвращает случайное значение типа boolean: false или true. Очень удобно, если нужно получить длинную последовательность 
случайных логических значений.

--------------------------------------------------------------------------------------------------
					~~~~~~~~~~~~  MATH ~~~~~~~~~~~~~~

abs(double value): возвращает абсолютное значение для аргумента value (модуль числа)
double result = Math.abs(-13.5); // 13.5

pow(double a, double b): возвращает число a, возведенное в степень b (ИТОГ ВСЕГДА ТИПА double)

sqrt(double value): возвращает квадратный корень числа value
double result1 = Math.sqrt(16); // 4

cbrt(double value): возвращает кубический корень числа value
double result = Math.cbrt(27); // 3

max(double a, double b): возвращает максимальное число из a и b

min(double a, double b): возвращает минимальное число из a и b

random(): возвращает случайное число от 0.0 до 1.0

scalb(double value, int factor): возвращает произведение числа value на 2 в степени factor
System.out.println(Math.scalb(5, 3)); // 5*2*2*2 = 40
System.out.println(Math.scalb(3, 4)); // 3*2*2*2*2 = 48

signum(double value): возвращает число 1, если число value положительное, и -1, если значение value отрицательное. 
Если value равно 0, то возвращает 0
System.out.println(Math.signum(2.3)); // 1
System.out.println(Math.signum(-2.3)); // -1

toDegrees(double value) переводит радианы в градусы и toRadians(double value) - градусы в радианы

Если хотите облегчить себе жизнь, то примените свойство степеней: корень N-й степени из числа X в степени Y равняется Х в степени Y/N (abs(x));

			~~~~~~ ОКРУГЛЕНИЕ ~~~~~~~

round(double d): возвращает число d, округленное до ближайшего целого числа  (СТАНДАРТНОЕ)
System.out.println(Math.round(2.3)); // 2
System.out.println(Math.round(2.5)); // 3
System.out.println(Math.round(2.5001)); // 3
System.out.println(Math.round(2.8)); // 3

floor(double d): возвращает наибольшее целое число, которое не больше d (ПРИЗЕМЛЯЕТ)
double result = Math.floor(2.56); // 2

ceil									(К БОЛЬШЕМУ)
    System.out.println(Math.ceil(1.3)); // 2.0
    System.out.println(Math.ceil(1.4)); // 2.0
    System.out.println(Math.ceil(1.5)); // 2.0
    System.out.println(Math.ceil(1.6)); // 2.0

rint(double value): возвращает число double, которое представляет ближайшее к числу value целое число
System.out.println(Math.rint(2)); // 2.0
System.out.println(Math.rint(2.3)); // 2.0
System.out.println(Math.rint(2.5)); // 2.0
System.out.println(Math.rint(2.5001)); // 3.0
System.out.println(Math.rint(2.8)); // 3.0



signum(double value): возвращает число 1, если число value положительное, и -1, если значение value отрицательное. 
Если value равно 0, то возвращает 0
System.out.println(Math.signum(2.3)); // 1
System.out.println(Math.signum(-2.3)); // -1

sin(double value): возвращает синус угла value

        System.out.println(Math.sin(Math.toRadians(0)));
        System.out.println(Math.sin(Math.toRadians(30)));
        System.out.println(Math.sin(Math.toRadians(90)));

cos(double d): возвращает косинус угла d

tan(double value): возвращает тангенс угла value

toDegrees(double value) переводит радианы в градусы и toRadians(double value) - градусы в радианы
System.out.println(Math.toDegrees(3.14159)); // 180
System.out.println(Math.toRadians(90)); // 1,57079....

Math.PI
long area = Math.round(Math.PI * Math.pow(radius, 2));
--------------------------------------------------------------------------------------------------
				~~~~~~~~~  ARRAY ~~~~~~~~~~~
int[] arr = new int[5];
arr[2] = 42;

System.out.println(arr[2]);    // 42
System.out.println(arr[3]);    // 0

Обратите внимание, что индексация элементов в массиве начинается с нуля. 
Таким образом, индекс первого элемента равен 0, а не единице, а максимальный индекс массива int[5] равен 4.

String[] names = {"A", "B", "C", "D"};   // размер массива задается автоматически
System.out.println(names[2]); // C

				Длина массива

Количество элементов в массиве называется его длиной. Получить длину массива можно через атрибут length.

int[] newArray = new int[5];
System.out.println(newArray.length); 	// 5
Обратите внимание - length у массива - это не метод, а атрибут, т. е. свойство данного массива, поэтому вызывается без круглых скобок в конце.



Если необходимо обойти весь массив (все элементы), удобно использовать СОКРАЩЕННЫЙ ЦИКЛ, вот его запись:

String[] beatles = {"John", "Paul", "Ringo", "George"};

for (String person: beatles) {
    System.out.println(person);
}


				УДОБНЫЙ ВВОД МАССИВА
for (int i = 0; i < arr.length; arr[i++] = sc.nextInt());



			    Построение массива из строки

В классе String имеется очень полезный метод split(). 
С помощью этого метода можно разделить имеющуюся строку на массив типа String[].

String str = "I'll be back";
String[] words = str.split(" ");	// создали массив и заполнили его строками
for (String word: words) {		// создаем строку, присваиваем ей массив (построчно?)
    System.out.println(word);		// механизм неясен, System.out.println(String word: words); - не работает
}					 // [I@b800 - этот хеш-код будет изменяться при каждом запуске

/* 
I'll
be
back
*/Построение массива из строки

			ВВОД, РАЗДЕЛЕНИЕ И ВЫВОД МАССИВА ОДНОЙ СТРОКОЙ

String[] arr = new Scanner(System.in).nextLine().split(" ");

for (String[] num : new Scanner(System.in).nextLine().split(",")){System.out.println(num);}



					МЕТОДЫ МАССИВОВ

Для работы с массивами в java есть специальный класс Arrays. Вот некоторые полезные методы, которые он предоставляет. 

Вначале класс нужно импортировать (так же, как мы импортируем java.util.Scanner):

import java.util.Arrays;



1. Arrays.toString(). 

Метод преобразует массив в строку. Полезен, прежде всего, для вывода массива на печать. Если попытаться напечатать массив напрямую, то мы получим вместо массива его шестнадцатеричный хеш-код:

int[] array = {1, 2, 3, 4, 5}; 
System.out.println(array);       // [I@b800 - этот хеш-код будет изменяться при каждом запуске
Поэтому, для начала, массив нужно преобразовать в строку:

int[] array = {1, 2, 3, 4, 5}; 
System.out.println(Arrays.toString(array));       // [1, 2, 3, 4, 5] - именно в таком виде выведет



2. Arrays.sort().  // по индексу элементов (с 0 до! Х (не включительно))

Этот метод сортирует массив или его часть.

int[] array = {5, 10, 15, 4, 1};

Arrays.sort(array);
System.out.println(Arrays.toString(array)); // [1, 4, 5, 10, 15]

Можно отсортировать только часть массива, указав начальный и конечный индексы при вызове метода:

int[] array = {5, 10, 15, 4, 1, 7, 23, 8, 11, 42};
Arrays.sort(array, 3, 7);
System.out.println(Arrays.toString(array));    // [5, 10, 15, 1, 4, 7, 23, 8, 11, 42]
В этом примере мы отсортировали только элементы массива с индексами от 3 до 6 (правая граница не входит в отрезок сортировки).

Обратите внимание: метод ничего не возвращает, а сортирует массив "на месте" (в самом массиве, видоизменяет его). 
Если попытаться присвоить результат работы метода какой-нибудь переменной, компилятор выдаст ошибку.

Можно сортировать и массивы из строк. В этом случае, сортировка производится в лексикографическом порядке.  

String[] array = {"one", "two", "three", "four"};
Arrays.sort(array);
System.out.println(Arrays.toString(array));    // [four, one, three, two]


3. Arrays.equals() и Arrays.deepEquals(a, b) - для многомерных массивов

Этот метод сравнивает два массива и возвращает true, если они равны, и false - в обратном случае.

int[] numbers1 = {1, 2, 3};
int[] numbers2 = {1, 2, 3};

System.out.println(Arrays.equals(numbers1, numbers2));    // true

int[] numbers3 = {1, 2, 3, 4};

boolean result = Arrays.equals(numbers1, numbers3);
System.out.println(result);    // false

Особое внимание необходимо обратить, что сравнивать массивы необходимо именно с помощью статического метода класса, 
а не так, как мы сравнивали строки (с помощью метода экземпляра).

int[] numbers1 = {1, 2, 3};
int[] numbers2 = {1, 2, 3};

System.out.println(number1.equals(numbers2));    // false
Так происходит потому, что массив является ссылочным типом данных, то есть, переменная содержит не сами данные, 
а только ссылку на них. В этом случае Java сравнивает между собой не данные, а ссылки на объекты. 
Поскольку объекты разные, то и результат сравнения получается false. 


4. Arrays.copyOf()  // по количеству элементов (не по индексу)

Метод возвращает копию массива. Метод получает в качестве аргументов массив, который нужно скопировать, и число элементов, 
которые нужно скопировать. Отсчёт ведётся с первого элемента массива.

int[] numbers1 = {1, 2, 3, 4, 5};
int[] numbers2 = Arrays.copyOf(numbers1, 5);

System.out.println(Arrays.toString(numbers2));    // [1, 2, 3, 4, 5]


int[] numbers3 = Arrays.copyOf(numbers1, 3);

System.out.println(Arrays.toString(numbers3));    // [1, 2, 3]


Если нужно скопировать весь массив, можно передать в качестве аргумента его длину:

int[] numbers1 = {1, 2, 3, 4, 5};
int[] numbers2 = Arrays.copyOf(numbers1, numbers1.length);

System.out.println(Arrays.toString(numbers2));    // [1, 2, 3, 4, 5]
Важно понимать разницу между приравниванием массивов друг другу и копированием:

int[] numbers1 = {1, 2, 3, 4, 5};
int[] numbers2 = numbers1;
int[] numbers3 = Arrays.copyOf(numbers1, numbers1.length);

numbers1[3] = 1000;

System.out.println(Arrays.toString(numbers2));    // [1, 2, 3, 1000, 5]

System.out.println(Arrays.toString(numbers3));    // [1, 2, 3, 4, 5]

​
Так получается потому, что numbers1 и numbers2 ссылаются на один и тот же объект, а numbers1 и numbers3 - на разные. 

Таким образом, метод Arrays.copyOf() создаёт новый, независимый от оригинального, массив.


5. Arrays.copyOfRange()		// по индексу, конечный элемент не включен

Если нужно скопировать не массив целиком, а только его кусок, подойдёт метод Arrays.copyOfRange(). 
Этот метод получает на вход массив, а также стартовый и конечный индексы "куска", который нужно скопировать:

int[] numbers1 = {2, 4, 6, 8, 10, 12, 14, 16};

int [] numbers2 = Arrays.copyOfRange(numbers1, 2, 5);
System.out.println(Arrays.toString(numbers2));    // [6, 8, 10]
Мы получили новый массив, вырезанный из первоначального, включая начальный индекс (2), но не включая конечный.

6. deepToString() - удобный вывод двумерного массива

7. Arrays.fill()
Класс Arrays имеет набор методов, называемых fill(), которые заполняют весь массив одним и тем же значением. 
Это бывает полезно, когда нужно очистить массив или проинициализировать все его ячейки определенными значениями.
Применение fill() заменяет использование цикла, скрывая все подробности внутри себя. В итоге остается одна лаконичная строка.
Пример:
int[] nums = new int[4];
Arrays.fill(nums, 36);
System.out.println(Arrays.toString(nums));
Вывод:
[36, 36, 36, 36]

8. System.arraycopy - из исходного массива (src), начиная с начальной позиции (srcPos), нужно скопировать данные в 
другой массив (dest), в такую-то позицию (destPos), в таком-то количестве (length). НЕ умеет продлевать массив, в который копируем.

9. Arrays.binarySearch(arr, <значение элемента>) - искать заданное значение в массиве. Возвращает номер элемента в массиве, кот содерж
наше значение.Если искомых элементов в массиве несколько, просто вернется номер одного из них (нет гарантий, что это будет, допустим, 
самый первый или наоборот — самый последний из одинаковых элементов).
Если элемент в массиве не найден, индекс будет отрицательным.

10. 

Пример слияния массивов (присваивать не нужно):
System.arraycopy(firstArray, 0, arr, 0, firstArray.length);
System.arraycopy(secondArray, 0, arr, firstArray.length, secondArray.length);
--------------------------------------------------------------------------------------------------

		~~~~~~~~~~~~~~~~~  PRINTF ФОРМАТИРОВАННЫЙ ВЫВОД ~~~~~~~~~~~~~~~~~~

Но в Java есть также функция для форматированного вывода, унаследованная от языка С: System.out.printf(). 
С ее помощью мы можем переписать предыдущий пример следующим образом:

int x=5;
int y=6;
System.out.printf("x=%d; y=%d \n", x, y);
В данном случае символы %d обозначают спецификатор, вместо которого подставляет один из аргументов. Спецификаторов и соответствующих им аргументов может быть множество. 
В данном случае у нас только два аргумента, поэтому вместо первого %d подставляет значение переменной x, а вместо второго - значение переменной y. 
Сама буква d означает, что данный спецификатор будет использоваться для вывода целочисленных значений.

Кроме спецификатора %d мы можем использовать еще ряд спецификаторов для других типов данных:

%x: для вывода шестнадцатеричных чисел

%f: для вывода чисел с плавающей точкой

%e: для вывода чисел в экспоненциальной форме, например, 1.3e+01

%c: для вывода одиночного символа

%s: для вывода строковых значений


public class Program {
   
    public static void main(String[] args) {
           
        String name = "Tom";
        int age = 30;
        float height = 1.7f;
          
        System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
    }
}
При выводе чисел с плавающей точкой мы можем указать количество знаков после запятой, для этого используем спецификатор на %.2f, 
где .2 указывает, что после запятой будет два знака. В итоге мы получим следующий вывод:

Name: Tom  Age: 30  Height: 1,70
--------------------------------------------------------------------------------------------------
				~~~~~~~~~~~  КЛАСС INTEGER  ~~~~~~~~~~~~~~~~
Методы класса Java.lang.Integer
Метод	Модификатор и Тип	Описание
bitCount(int i)	static int	Возвращает количество 1 (ЕДИНИЦ) в двоичном коде (МОЖНО ОПРЕДЕЛИТЬ СТЕПЕНЬ ДВОЙКИ) если единичка одна,
				то число - степень двойки.
byteValue()	byte	Возвращает значение этого целого числа в байтах.
compare(int x, int y)	static int	Сравнивает два значения int численно.
compareTo(Integer anotherInteger)	int	Численно сравнивает два объекта Integer.
decode(String nm)	static Integer	Декодирует строку в целое число.
doubleValue()	double	Возвращает значение этого Integer как double.
equals(Object obj)	boolean	Сравнивает этот объект с указанным объектом.
floatValue()	float	Возвращает значение этого целого числа как число с плавающей точкой.
getInteger(String nm)	static Integer	Determines the integer value of the system property with the specified name.
hashCode()	int	Возвращает хеш-код для этого Integer.
intValue()	int	Возвращает значение этого целого числа в виде целого числа.
longValue()	long	Возвращает значение этого Integer как long.
lowestOneBit(int i)	static Int	Возвращает значение типа int, содержащее не более одного бита, в позиции младшего бита («самого правого») в указанном intvalue.
reverse(int i)	static Int	Возвращает значение, полученное путем изменения порядка битов в двоичном представлении дополнения до двух указанных значений int.
reverseBytes(int i)	static Int	Возвращает значение, полученное путем изменения порядка следования байтов в представлении дополнения до двух указанных значений int.
shortValue()	short	Возвращает значение этого целого числа в виде short.
toString()	String	Возвращает объект String, представляющий значение этого целого числа.
toString(int i)	static String	Возвращает объект String, представляющий указанное целое число.
valueOf(int i)	static Integer	Возвращает экземпляр Integer, представляющий указанное значение типа int.
valueOf(String s)	static Integer	Возвращает объект Integer, содержащий значение указанной строки.
Источник: https://java-blog.ru/osnovy/klass-integer-java
--------------------------------------------------------------------------------------------------
				~~~~~~~~~~ ФИШКИ ПОБИТОВОГО СДВИГА ~~~~~~~~~~~~~~

1. ВОТКНУТЬ ЕДИНИЦУ В ДВОИЧНОЕ ЧИСЛО. 
ЧИСЛО XOR (1 << на количество символов)	
1000
0100 ЕСЛИ СДВИГ НА 2
1100 

2. Что бы узнать явлется ли число 1, а дальше 000 (нули), т.е. степенью двойки (10 - 2, 100 - 4, 1000 - 8). ДЕЛАЕМ ЧЕРЕЗ И.

10=2, 100=4, 1000=8, 10.000=16, 100.000=32 и так далее. ОТНИМАЕМ ОТ ЧИСЛА 1 И СРАВНИВАЕМ ПОБИТОВЫМ "И" НА РАВЕНСТВО 0
01=1, 011=3, 0111=7, 01.111=15, 011.111=31 и так далее. 

НУ ИЛИ МОЖНО XOR (ВСЕ ЕДИНИЦЫ В ИТОГЕ). ЧИСЛО XOR ЧИСЛО - 1 == ЧИСЛО - 1 << ПОБИТОВЫЙ СДВИГ ВЛЕВО + 1 

3. Заменить единицу на ноль (ДЕЛАЕТСЯ ЧЕРЕЗ ПОБИТОВОЕ НЕ)
1100
0100
1000
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
			~~~~~~~ ПРИМЕРЫ ~~~~~~~~

0. Возвращает количество слов в строке: sc.nextLine().split(" ").length

1. Инициализация и заполнение двумерного массива без заранее известного значения второго измерения:
(ТО ЕСТЬ ОБЪЯВЛЯЕМ КОЛ-ВО СТРОК И ЗАПОЛНЯЕМ ИХ КОЛ-ВОМ СТОЛБЦОВ В ПРОЦЕССЕ ВЫПОЛНЕНИЯ)

import java.util.Scanner;
import java.util.Arrays;

class MyClass {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String s = sc.nextLine();
        String[][] arr = new String[n][];

       for (int i = 0; i < n; i++)
           arr[i] = sc.nextLine().split(" ");

        for (int i1 = 0; i1 < n; i1++)
        System.out.println(Arrays.toString(arr[i1]));
    }
}

2. Нахождение максимальной цифры из введенного числа:

import java.util.Scanner;

class MyNumber {
    public static void main(String[] args) {
        long n = new Scanner(System.in).nextLong(), max = 0;
        n = Math.abs(n);
        while (n > 0){
            if (n % 10 > max){
                max = n % 10;
            }
            n /= 10;
        }
        System.out.println(max);
    }
}

3. Обрезка строк массива (удаление пробела в конце):

        for (int i1 = 0; i1 < arr[0].length; i++)
            for (int i2 = i - 1; i2 > -1; i2--)
                System.out.println(arr[i1][i2] + (i2 == 0 ? " " : "\n"));

4. Заполнение двумерного массива без инфо о его размере (через строку):

        for (i = 0; sc.hasNext(); i++)
            s += sc.nextLine().trim() + " ";

        String[] t_arr = s.split(" ");

        String[][] t_arr_2 = new String[i][t_arr.length / i];
        for (int i1 = 0; i1 < i; i1++)
            for (int i2 = 0; i2 < t_arr.length / i; i2++) {
                t_arr_2[i1][i2] = t_arr[count];
                count++;
	    }

5. Заполнение двумерного массива без инфо о его размере (динамическая инициализация):

import java.util.Arrays;
import java.util.Scanner;

class MyClass {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int i = 0;
        String[][] arr = new String[0][];

        while (sc.hasNextLine()) {
            arr = Arrays.copyOf(arr,i+1);  // Следует иметь ввиду небольшой нюанс работы метода, связанный с тем, что если количество копируемых элементов указано больше, чем их содержит массив, то copyOf() дополнит итоговый массив значениями по умолчанию.
            arr[i] = sc.nextLine().split(" ");
            System.out.println(Arrays.toString(arr[i]));
            i++;
        }

        sc.close();
    }
}
6. Под все число отводится 64 бита. Под знак – 1 бит. Под порядок – 11 бит. Под мантиссу – 52 бита.
--------------------------------------------------------------------------------------------------
			~~~~~~~~~~ ЗАГОТОВКИ ~~~~~~~~~~~~~~~

----------------СОРТИРОВКА ВЫБОРОМ------------------
Допустим, перевый элемент массива мин, сравниваем его с остальными и меняем местами с тем, кот самый маленький.


 for (int i = 0; i < arr.length - 1; i++) {
            min = arr[i];
            pos = i;
            for (int i1 = i + 1; i1 < arr.length; i1++) {
                if (arr[i1] <= min) {
                    min = arr[i1];
                    pos = i1;
                }
            }
            arr[pos] = arr[i];
            arr[i] = min;
        }

------------- СОРТИРОВКА ПУЗЫРЬКОМ ----------------
Сравнивает два соседних элемента и меняет их местами, до тех пор, пока перемены не будет.
do {
            stop = true;
            for (int i = 0; i < arr.length - 1; i++) {
                if (arr[i + 1] < arr[i]) {
                    temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    stop = false;
                }
            }
        } while (stop == false);

------------- СОРТИРОВКА СЛИЯНИЕМ Ч.1 (РЕКУРСИЯ, СРАВНЕНИЕ 2-Х элементов) ----------------
Итак, идея в том, что массив разбивается на две части (левая половина и правая), потом еще раз и так до состояния одного элемента в 
массиве, потом они сравниваются и объединяются в два итоговых отсортированных массива, коротые отправляются на слияние.

Разбиваем до 1 или двух элементов (если 2, то сортируем их). Если 5 элементов (5,4,3,2,1), то:
merge(4,5 и merge(3 и 1,2));
Хорошо, а если элементов 7 {7,6,5,4,3,2,1}, то:
merge (merge (7 & 5,6) И merge(3,4 & 1,2))

class MyClass {
    static int z = 1;

    public static void main(String[] args) {

        System.out.println(Arrays.toString(split(new int[] {3,2,1})));
    }

    public static int[] split(int[] array) {
        System.out.println(z++);
        if (array.length == 1) return array;
        if (array.length == 2) return mergeArrays(new int[] {array[0]}, new int[] {array[1]});

        int[] left = new int[array.length / 2];
        int[] right = new int[array.length - array.length / 2];

        System.arraycopy(array, 0, left, 0, left.length);
        System.arraycopy(array, left.length, right, 0, right.length);

        System.out.println(Arrays.toString(left));
        System.out.println(Arrays.toString(right));

        return mergeArrays(split(left), split(right));
    }

    public static int[] mergeArrays(int[] a1, int[] a2) {
        int[] a = new int[a1.length + a2.length];
        int i = 0, i1 = 0, i2 = 0;

        while (i1 < a1.length && i2 < a2.length) a[i++] = a1[i1] < a2[i2] ? a1[i1++] : a2[i2++];
        while (i1 < a1.length) a[i++] = a1[i1++];
        while (i2 < a2.length) a[i++] = a2[i2++];
        System.out.println(Arrays.toString(a) + " i1");
        return a;
    }
}

------------- ПРОСТАЯ ЗАВОДСКАЯ СОРТИРОВКА ДВУХ СЛИТЫХ ВОЕДИНО МАССИВОВ ----------------

int [] arr = new int[a1.length + a2.length];

        System.arraycopy(a1, 0, arr, 0, a1.length);
        System.arraycopy(a2, 0, arr, a1.length, a2.length);
        Arrays.sort(arr);
        return arr;

https://pro.rbc.ru/demo/65c0ce9c9a7947b1d874503a?from=from_main_5&utm_source=rbc.ru&utm_medium=inhouse_media&utm_campaign=lines_5&utm_content=65c0ce9c9a7947b1d874503a&utm_term=10.4B_noauth_alt

----------------СКОЛЬКО ПАМЯТИ ПОТРЕБЛЯЕТ ПРОГРАММА-----------------------

Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / 1048576;

